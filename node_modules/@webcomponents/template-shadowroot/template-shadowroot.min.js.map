{"version":3,"file":"template-shadowroot.min.js","sources":["src/_implementation/feature_detect.ts","src/_implementation/util.ts","src/_implementation/manual_walk.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n// This isn't ideal. Setting .innerHTML is not compatible with some\n// TrustedTypes CSP policies. Discussion at:\n//     https://github.com/mfreed7/declarative-shadow-dom/issues/3\nlet hasNative: boolean|undefined;\nexport function hasNativeDeclarativeShadowRoots(): boolean {\n  if (hasNative === undefined) {\n    const div = document.createElement('div');\n    div.innerHTML = `<div><template shadowroot=\"open\"></template></div>`;\n    hasNative = !!div.firstElementChild!.shadowRoot;\n  }\n  return hasNative;\n}\n","/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nexport const hasNoParentElement =\n    (e: Element|DocumentFragment): e is DocumentFragment =>\n        e.parentElement === null;\nexport const isTemplate = (e: Node): e is HTMLTemplateElement =>\n    (e as Partial<Element>).tagName === 'TEMPLATE';\nexport const isElement = (e: Node): e is HTMLElement =>\n    e.nodeType === Node.ELEMENT_NODE;\n","/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {hasNativeDeclarativeShadowRoots} from './feature_detect.js';\nimport {hasNoParentElement, isElement, isTemplate} from './util.js';\n\n/*\n * Traverses the DOM to find all <template> elements with a `shadowroot`\n * attribute and move their content into a ShadowRoot on their parent element.\n *\n * This processing is done bottom up so that when top-level <template>\n * elements are hydrated, their contents are already hydrated and in the\n * final correct structure of elements and shadow roots.\n */\nexport const hydrateShadowRoots = (root: ParentNode) => {\n  if (hasNativeDeclarativeShadowRoots()) {\n    return;  // nothing to do\n  }\n\n  // Approaches to try and benchmark:\n  //  - manual walk (current implementation)\n  //  - querySelectorAll\n  //  - TreeWalker\n\n  // Stack of nested templates that we're currently processing. Use to\n  // remember how to get from a <template>.content DocumentFragment back to\n  // its owner <template>\n  const templateStack: Array<HTMLTemplateElement> = [];\n\n  let currentNode: Element|DocumentFragment|null = root.firstElementChild;\n\n  // The outer loop traverses down, looking for <template shadowroot>\n  // elements. The inner loop traverses back up, hydrating them in a postorder\n  // traversal.\n  while (currentNode !== root && currentNode !== null) {\n    if (isTemplate(currentNode)) {\n      templateStack.push(currentNode);\n      currentNode = currentNode.content;\n    } else if (currentNode.firstElementChild !== null) {\n      // Traverse down\n      currentNode = currentNode.firstElementChild;\n    } else if (\n        isElement(currentNode) && currentNode.nextElementSibling !== null) {\n      // Element is empty, but has a next sibling. Traverse that.\n      currentNode = currentNode.nextElementSibling;\n    } else {\n      // Element is empty and the last child. Traverse to next aunt/grandaunt.\n\n      // Store templates we hydrate for one loop so that we can remove them\n      // *after* traversing to their successor.\n      let template: HTMLTemplateElement|undefined;\n\n      while (currentNode !== root && currentNode !== null) {\n        if (hasNoParentElement(currentNode)) {\n          // We must be at a <template>'s content fragment.\n          template = templateStack.pop()!;\n          const host = template.parentElement!;\n          const mode = template.getAttribute('shadowroot');\n          currentNode = template;\n          if (mode === 'open' || mode === 'closed') {\n            const delegatesFocus =\n                template.hasAttribute('shadowrootdelegatesfocus');\n            try {\n              const shadow = host.attachShadow({mode, delegatesFocus});\n              shadow.append(template.content);\n            } catch {\n              // there was already a shadow root.\n              // TODO(rictic): log an error event?\n            }\n          } else {\n            template = undefined;\n          }\n        } else {\n          const nextSibling: Element|null|undefined =\n              currentNode.nextElementSibling;\n          if (nextSibling != null) {\n            currentNode = nextSibling;\n            if (template !== undefined) {\n              template.parentElement!.removeChild(template);\n            }\n            break;\n          }\n          const nextAunt: Element|null|undefined =\n              currentNode.parentElement?.nextElementSibling;\n          if (nextAunt != null) {\n            currentNode = nextAunt;\n            if (template !== undefined) {\n              template.parentElement!.removeChild(template);\n            }\n            break;\n          }\n          currentNode = currentNode.parentElement;\n          if (template !== undefined) {\n            template.parentElement!.removeChild(template);\n            template = undefined;\n          }\n        }\n      }\n    }\n  }\n};\n"],"names":["hasNative","hasNativeDeclarativeShadowRoots","undefined","div","document","createElement","innerHTML","firstElementChild","shadowRoot","hasNoParentElement","e","parentElement","isElement","nodeType","Node","ELEMENT_NODE","root","templateStack","currentNode","tagName","push","content","nextElementSibling","template","pop","host","mode","getAttribute","delegatesFocus","hasAttribute","attachShadow","append","nextSibling","removeChild","nextAunt"],"mappings":";;;;;;AASA,IAAIA,WACYC,IACd,QAAkBC,IAAdF,EAAyB,CAC3B,MAAMG,EAAMC,SAASC,cAAc,OACnCF,EAAIG,UAAY,qDAChBN,IAAcG,EAAII,kBAAmBC,WAEvC,OAAOR;;;;;OCVF,MAAMS,EACRC,GACuB,OAApBA,EAAEC,cAGGC,EAAaF,GACtBA,EAAEG,WAAaC,KAAKC;;;;;wECKWC,UACjC,GAAIf,IACF,OAWF,MAAMgB,EAA4C,GAElD,IAAIC,EAA6CF,EAAKT,kBAKtD,KAAOW,IAAgBF,GAAwB,OAAhBE,GAC7B,GD5BoC,aC4BrBA,ED5BSC,QC6BtBF,EAAcG,KAAKF,GACnBA,EAAcA,EAAYG,aACrB,GAAsC,OAAlCH,EAAYX,kBAErBW,EAAcA,EAAYX,uBACrB,GACHK,EAAUM,IAAmD,OAAnCA,EAAYI,mBAExCJ,EAAcA,EAAYI,uBACrB,CAKL,IAAIC,EAEJ,KAAOL,IAAgBF,GAAwB,OAAhBE,GAC7B,GAAIT,EAAmBS,GAAc,CAEnCK,EAAWN,EAAcO,MACzB,MAAMC,EAAOF,EAASZ,cAChBe,EAAOH,EAASI,aAAa,cAEnC,GADAT,EAAcK,EACD,SAATG,GAA4B,WAATA,EAAmB,CACxC,MAAME,EACFL,EAASM,aAAa,4BAC1B,IACiBJ,EAAKK,aAAa,CAACJ,KAAAA,EAAME,eAAAA,IACjCG,OAAOR,EAASF,SACvB,aAKFE,OAAWrB,MAER,CACL,MAAM8B,EACFd,EAAYI,mBAChB,GAAmB,MAAfU,EAAqB,CACvBd,EAAcc,OACG9B,IAAbqB,GACFA,EAASZ,cAAesB,YAAYV,GAEtC,MAEF,MAAMW,YACFhB,EAAYP,oCAAeW,mBAC/B,GAAgB,MAAZY,EAAkB,CACpBhB,EAAcgB,OACGhC,IAAbqB,GACFA,EAASZ,cAAesB,YAAYV,GAEtC,MAEFL,EAAcA,EAAYP,mBACTT,IAAbqB,IACFA,EAASZ,cAAesB,YAAYV,GACpCA,OAAWrB"}