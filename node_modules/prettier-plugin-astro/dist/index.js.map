{"version":3,"file":"index.js","sources":["../src/nodes.ts","../src/utils.ts","../src/printer.ts","../src/options.ts","../src/index.ts"],"sourcesContent":["import {\n\tNode,\n\tAttributeNode,\n\tRootNode,\n\tElementNode,\n\tComponentNode,\n\tCustomElementNode,\n\tExpressionNode,\n\tTextNode,\n\tFrontmatterNode,\n\tDoctypeNode,\n\tCommentNode,\n\tFragmentNode,\n} from '@astrojs/compiler/types';\n\n// MISSING ATTRIBUTE NODE FROM THE NODE TYPE\n\nexport interface NodeWithText {\n\tvalue: string;\n}\n\n// export interface Ast {\n//   html: anyNode;\n//   css: StyleNode[];\n//   module: ScriptNode;\n//   meta: {\n//     features: number;\n//   };\n// }\n\n// export interface BaseNode {\n//   start: number;\n//   end: number;\n//   type: string;\n//   children?: anyNode[];\n//   // TODO: ADD BETTER TYPE\n//   [prop_name: string]: any;\n// }\n\n// export type attributeValue = TextNode[] | AttributeShorthandNode[] | MustacheTagNode[] | true;\n\nexport interface NodeWithChildren {\n\t// children: anyNode[];\n\tchildren: Node[];\n}\n\n// export interface NodeWithText {\n//   data: string;\n//   raw?: string;\n// }\n\n// export interface FragmentNode extends BaseNode {\n//   type: 'Fragment';\n//   children: anyNode[];\n// }\n\n// export interface TextNode extends BaseNode {\n//   type: 'Text';\n//   data: string;\n//   raw: string;\n// }\n\n// export interface CodeFenceNode extends BaseNode {\n//   type: 'CodeFence';\n//   metadata: string;\n//   data: string;\n//   raw: string;\n// }\n\n// export interface CodeSpanNode extends BaseNode {\n//   type: 'CodeSpan';\n//   metadata: string;\n//   data: string;\n//   raw: string;\n// }\n\n// export interface SpreadNode extends BaseNode {\n//   type: 'Spread';\n//   expression: ExpressionNode;\n// }\n\n// export interface ExpressionNode {\n//   type: 'Expression';\n//   start: number;\n//   end: number;\n//   codeChunks: string[];\n//   children: anyNode[];\n// }\n\n// export interface ScriptNode extends BaseNode {\n//   type: 'Script';\n//   context: 'runtime' | 'setup';\n//   content: string;\n// }\n\n// export interface StyleNode extends BaseNode {\n//   type: 'Style';\n//   // TODO: ADD BETTER TYPE\n//   attributes: any[];\n//   content: {\n//     start: number;\n//     end: number;\n//     styles: string;\n//   };\n// }\n\n// export interface AttributeNode extends BaseNode {\n//   type: 'Attribute';\n//   name: string;\n//   value: attributeValue;\n// }\n\n// export interface AttributeShorthandNode extends BaseNode {\n//   type: 'AttributeShorthand';\n//   expression: IdentifierNode;\n// }\n\n// export interface IdentifierNode extends BaseNode {\n//   type: 'Identifier';\n//   name: string;\n// }\n\n// export interface MustacheTagNode extends BaseNode {\n//   type: 'MustacheTag';\n//   expression: ExpressionNode;\n// }\n\n// export interface SlotNode extends BaseNode {\n//   type: 'Slot';\n//   name: string;\n//   attributes: AttributeNode[];\n// }\n\n// export interface CommentNode extends BaseNode {\n//   type: 'Comment';\n//   data: string;\n//   name?: string;\n//   leading?: boolean;\n//   trailing?: boolean;\n//   printed?: boolean;\n//   nodeDescription?: string;\n// }\n\n// export interface ElementNode extends BaseNode {\n//   type: 'Element';\n//   name: string;\n//   attributes: AttributeNode[];\n// }\n\n// export interface InlineComponentNode extends BaseNode {\n//   type: 'InlineComponent';\n//   name: string;\n//   attributes: AttributeNode[];\n// }\n\nexport interface BlockElementNode extends ElementNode {\n\tname: typeof blockElementsT[number];\n}\n\nexport interface InlineElementNode extends ElementNode {\n\tname: typeof inlineElementsT[number];\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements#Elements\nconst blockElementsT = [\n\t'address',\n\t'article',\n\t'aside',\n\t'blockquote',\n\t'details',\n\t'dialog',\n\t'dd',\n\t'div',\n\t'dl',\n\t'dt',\n\t'fieldset',\n\t'figcaption',\n\t'figure',\n\t'footer',\n\t'form',\n\t'h1',\n\t'h2',\n\t'h3',\n\t'h4',\n\t'h5',\n\t'h6',\n\t'header',\n\t'hgroup',\n\t'hr',\n\t'li',\n\t'main',\n\t'nav',\n\t'ol',\n\t'p',\n\t'pre',\n\t'section',\n\t'table',\n\t'ul',\n\t// TODO: WIP\n\t'title',\n\t'html',\n] as const;\n// https://github.com/microsoft/TypeScript/issues/31018\nexport const blockElements: string[] = [...blockElementsT];\n\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Inline_elements\nconst inlineElementsT = [\n\t'a',\n\t'abbr',\n\t'acronym',\n\t'audio',\n\t'b',\n\t'bdi',\n\t'bdo',\n\t'big',\n\t'br',\n\t'button',\n\t'canvas',\n\t'cite',\n\t'code',\n\t'data',\n\t'datalist',\n\t'del',\n\t'dfn',\n\t'em',\n\t'embed',\n\t'i',\n\t'iframe',\n\t'img',\n\t'input',\n\t'ins',\n\t'kbd',\n\t'label',\n\t'map',\n\t'mark',\n\t'meter',\n\t'noscript',\n\t'object',\n\t'output',\n\t'picture',\n\t'progress',\n\t'q',\n\t'ruby',\n\t's',\n\t'samp',\n\t'script',\n\t'select',\n\t'slot',\n\t'small',\n\t'span',\n\t'strong',\n\t'sub',\n\t'sup',\n\t'svg',\n\t'template',\n\t'textarea',\n\t'time',\n\t'u',\n\t'tt',\n\t'var',\n\t'video',\n\t'wbr',\n] as const;\n// https://github.com/microsoft/TypeScript/issues/31018\nexport const inlineElements: string[] = [...inlineElementsT];\n\n// @see http://xahlee.info/js/html5_non-closing_tag.html\nexport const selfClosingTags = [\n\t'area',\n\t'base',\n\t'br',\n\t'col',\n\t'embed',\n\t'hr',\n\t'img',\n\t'input',\n\t'link',\n\t'meta',\n\t'param',\n\t'source',\n\t'track',\n\t'wbr',\n];\n\nexport type anyNode =\n\t| RootNode\n\t| AttributeNode\n\t| ElementNode\n\t| ComponentNode\n\t| CustomElementNode\n\t| ExpressionNode\n\t| TextNode\n\t| DoctypeNode\n\t| CommentNode\n\t| FragmentNode\n\t| FrontmatterNode;\n\nexport type {\n\tAttributeNode,\n\tNode,\n\tRootNode,\n\tElementNode,\n\tComponentNode,\n\tCustomElementNode,\n\tExpressionNode,\n\tTextNode,\n\tFrontmatterNode,\n\tDoctypeNode,\n\tCommentNode,\n\tFragmentNode,\n\tTagLikeNode,\n} from '@astrojs/compiler/types';\n","import { AstPath as AstP, doc, Doc, ParserOptions as ParserOpts, util } from 'prettier';\n\nimport {\n\tanyNode,\n\tNode,\n\tRootNode,\n\tAttributeNode,\n\tElementNode,\n\tComponentNode,\n\tCustomElementNode,\n\tExpressionNode,\n\tTextNode,\n\tFrontmatterNode,\n\tDoctypeNode,\n\tCommentNode,\n\tNodeWithText,\n\tblockElements,\n\t// attributeValue,\n\tBlockElementNode,\n\tInlineElementNode,\n\t// MustacheTagNode,\n\tNodeWithChildren,\n\tTagLikeNode,\n\t// NodeWithText,\n\t// TextNode,\n} from './nodes';\n\nimport { createSyncFn } from 'synckit';\nimport { createRequire } from 'module';\nconst require = createRequire(import.meta.url);\n\n// the worker path must be absolute\nconst serialize = createSyncFn(require.resolve('../workers/serialize-worker.js'));\n\ntype ParserOptions = ParserOpts<anyNode>;\ntype AstPath = AstP<anyNode>;\n\n/**\n * HTML attributes that we may safely reformat (trim whitespace, add or remove newlines)\n */\nexport const formattableAttributes: string[] = [\n\t// None at the moment\n\t// Prettier HTML does not format attributes at all\n\t// and to be consistent we leave this array empty for now\n];\n\n// const rootNodeKeys = new Set(['html', 'css', 'module']);\n\n// const isSync = makeSynchronous(async (node: anyNode) => {\n//   const dynamicImport = new Function('file', 'return import(file)');\n//   const { is } = await dynamicImport('@astrojs/compiler/utils');\n//   try {\n//     return await is(node);\n//   } catch (e) {\n//     console.error(e);\n//   }\n// });\n\n// export const is = (node: anyNode) => isSync(node);\n\nexport const isRootNode = (node: anyNode): node is RootNode => node.type === 'root';\n\nexport const isEmptyTextNode = (node: Node): boolean => {\n\treturn !!node && node.type === 'text' && getUnencodedText(node).trim() === '';\n};\n\nexport const isPreTagContent = (path: AstPath): boolean => {\n\tif (!path || !path.stack || !Array.isArray(path.stack)) return false;\n\treturn path.stack.some(\n\t\t(node: anyNode) =>\n\t\t\t(node.type === 'element' && node.name.toLowerCase() === 'pre') ||\n\t\t\t(node.type === 'attribute' && !formattableAttributes.includes(node.name))\n\t);\n};\n\nexport function isLoneMustacheTag(node: AttributeNode): boolean {\n\t// export function isLoneMustacheTag(node: AttributeNode): node is [MustacheTagNode] {\n\treturn node.kind === 'expression';\n\t// return node !== true && node.length === 1 && node[0].type === 'MustacheTag';\n}\n\n// function isAttributeShorthand(node: attributeValue): node is [AttributeShorthandNode] {\n//   return node !== true && node.length === 1 && node[0].type === 'AttributeShorthand';\n// }\n\n/**\n * True if node is of type `{a}` or `a={a}`\n */\nexport function isOrCanBeConvertedToShorthand(node: AttributeNode, opts: ParserOptions): boolean {\n\tif (!opts.astroAllowShorthand) return false;\n\tif (node.kind === 'shorthand') {\n\t\treturn true;\n\t}\n\t// if (isAttributeShorthand(node.value)) {\n\t//   return true;\n\t// }\n\n\tif (node.value.trim() === node.name.trim()) {\n\t\treturn true;\n\t}\n\n\t// if (isLoneMustacheTag(node.value)) {\n\t//   const expression = node.value[0].expression;\n\t//   return expression.codeChunks[0].trim() === node.name;\n\t//   // return (expression.type === 'Identifier' && expression.name === node.name) || (expression.type === 'Expression' && expression.codeChunks[0] === node.name);\n\t// }\n\n\treturn false;\n}\n\n/**\n *  True if node is of type `{a}` and astroAllowShorthand is false\n */\nexport function isShorthandAndMustBeConvertedToBinaryExpression(\n\tnode: AttributeNode,\n\topts: ParserOptions\n): boolean {\n\tif (opts.astroAllowShorthand) return false;\n\tif (node.type === 'attribute' && node.kind === 'shorthand') {\n\t\treturn true;\n\t}\n\t// if (isAttributeShorthand(node.value)) {\n\t//   return true;\n\t// }\n\treturn false;\n}\n\n// export function flatten<T>(arrays: T[][]): T[] {\n//   return ([] as T[]).concat.apply([], arrays);\n// }\n\n// TODO: TEST IF IT'S GETTING THE CORRECT TEXT\nexport function getText(node: anyNode, opts: ParserOptions): string {\n\tif (!node.position) return '';\n\treturn opts.originalText.slice(node.position.start.offset + 1, node.position.end?.offset);\n\t// return opts.originalText.slice(opts.locStart(node), opts.locEnd(node));\n}\n\nexport function getUnencodedText(node: NodeWithText): string {\n\treturn node.value;\n}\n\n// export function replaceEndOfLineWith(text: string, replacement: doc.builders.DocCommand): Doc[] {\n//   const parts = [];\n//   for (const part of text.split('\\n')) {\n//     if (parts.length > 0) {\n//       parts.push(replacement);\n//     }\n//     if (part.endsWith('\\r')) {\n//       parts.push(part.slice(0, -1));\n//     } else {\n//       parts.push(part);\n//     }\n//   }\n//   return parts;\n// }\n\n/**\n *  Returns the content of the node\n */\nexport function printRaw(node: anyNode, stripLeadingAndTrailingNewline = false): string {\n\tif (!isNodeWithChildren(node)) {\n\t\treturn '';\n\t}\n\n\tif (node.children.length === 0) {\n\t\treturn '';\n\t}\n\n\tlet raw = node.children.reduce((prev: string, curr: Node) => prev + serialize(curr), '');\n\n\tif (!stripLeadingAndTrailingNewline) {\n\t\treturn raw;\n\t}\n\n\tif (startsWithLinebreak(raw)) {\n\t\traw = raw.substring(raw.indexOf('\\n') + 1);\n\t}\n\tif (endsWithLinebreak(raw)) {\n\t\traw = raw.substring(0, raw.lastIndexOf('\\n'));\n\t\tif (raw.charAt(raw.length - 1) === '\\r') {\n\t\t\traw = raw.substring(0, raw.length - 1);\n\t\t}\n\t}\n\n\treturn raw;\n}\n\nexport function isNodeWithChildren(node: anyNode): node is anyNode & NodeWithChildren {\n\treturn node && 'children' in node && Array.isArray(node.children);\n}\n\nexport function isInlineElement(\n\tpath: AstPath,\n\topts: ParserOptions,\n\tnode: anyNode\n): node is InlineElementNode {\n\treturn node && node.type === 'element' && !isBlockElement(node, opts) && !isPreTagContent(path);\n}\n\nexport function isBlockElement(node: anyNode, opts: ParserOptions): node is BlockElementNode {\n\treturn (\n\t\tnode &&\n\t\tnode.type === 'element' &&\n\t\topts.htmlWhitespaceSensitivity !== 'strict' &&\n\t\t(opts.htmlWhitespaceSensitivity === 'ignore' || blockElements.includes(node.name))\n\t);\n}\n\nexport function isTextNodeStartingWithLinebreak(node: TextNode, nrLines = 1): node is TextNode {\n\treturn startsWithLinebreak(getUnencodedText(node), nrLines);\n\t// return node.type === 'Text' && startsWithLinebreak(getUnencodedText(node), nrLines);\n}\n\nexport function startsWithLinebreak(text: string, nrLines = 1): boolean {\n\treturn new RegExp(`^([\\\\t\\\\f\\\\r ]*\\\\n){${nrLines}}`).test(text);\n}\n\n// export function isTextNodeEndingWithLinebreak(node: TextNode, nrLines: number = 1) {\n//   return node.type === 'text' && endsWithLinebreak(getUnencodedText(node), nrLines);\n// }\n\nexport function endsWithLinebreak(text: string, nrLines = 1): boolean {\n\treturn new RegExp(`(\\\\n[\\\\t\\\\f\\\\r ]*){${nrLines}}$`).test(text);\n}\n\nexport function isTextNodeStartingWithWhitespace(node: Node): node is TextNode {\n\treturn node.type === 'text' && /^\\s/.test(getUnencodedText(node));\n}\n\nexport function isTextNodeEndingWithWhitespace(node: Node): node is TextNode {\n\treturn node.type === 'text' && /\\s$/.test(getUnencodedText(node));\n}\n\nexport function forceIntoExpression(statement: string): string {\n\t// note the trailing newline: if the statement ends in a // comment,\n\t// we can't add the closing bracket right afterwards\n\treturn `<>{${statement}\\n}</>`;\n}\n\n/**\n * Check if given node's starg tag should hug its first child. This is the case for inline elements when there's\n * no whitespace between the `>` and the first child.\n */\nexport function shouldHugStart(node: anyNode, opts: ParserOptions): boolean {\n\tif (isBlockElement(node, opts)) {\n\t\treturn false;\n\t}\n\n\tif (!isNodeWithChildren(node)) {\n\t\treturn false;\n\t}\n\n\tconst children = node.children;\n\tif (children.length === 0) {\n\t\treturn true;\n\t}\n\n\tconst firstChild = children[0];\n\treturn !isTextNodeStartingWithWhitespace(firstChild);\n}\n\n/**\n * Check if given node's end tag should hug its last child. This is the case for inline elements when there's\n * no whitespace between the last child and the `</`.\n */\nexport function shouldHugEnd(node: anyNode, opts: ParserOptions): boolean {\n\tif (isBlockElement(node, opts)) {\n\t\treturn false;\n\t}\n\n\tif (!isNodeWithChildren(node)) {\n\t\treturn false;\n\t}\n\n\tconst children = node.children;\n\tif (children.length === 0) {\n\t\treturn true;\n\t}\n\n\treturn false;\n\n\t// TODO: WIP\n\t// const lastChild = children[children.length - 1];\n\t// return !isTextNodeEndingWithWhitespace(lastChild);\n}\n\n/**\n * Returns true if the softline between `</tagName` and `>` can be omitted.\n */\nexport function canOmitSoftlineBeforeClosingTag(path: AstPath, opts: ParserOptions): boolean {\n\treturn isLastChildWithinParentBlockElement(path, opts);\n\t// return !hugsStartOfNextNode(node, options) || isLastChildWithinParentBlockElement(path, options);\n\t// return !options.svelteBracketNewLine && (!hugsStartOfNextNode(node, options) || isLastChildWithinParentBlockElement(path, options));\n}\n\n/**\n * Return true if given node does not hug the next node, meaning there's whitespace\n * or the end of the doc afterwards.\n */\n// function hugsStartOfNextNode(node: anyNode, opts: ParserOptions): boolean {\n//   if (node.end === opts.originalText.length) {\n//     // end of document\n//     return false;\n//   }\n\n//   return !opts.originalText.substring(node.end).match(/^\\s/);\n// }\n\nfunction getChildren(node: anyNode): Node[] {\n\treturn isNodeWithChildren(node) ? node.children : [];\n}\n\nfunction isLastChildWithinParentBlockElement(path: AstPath, opts: ParserOptions): boolean {\n\tconst parent = path.getParentNode();\n\tif (!parent || !isBlockElement(parent, opts)) {\n\t\treturn false;\n\t}\n\n\tconst children = getChildren(parent);\n\tconst lastChild = children[children.length - 1];\n\treturn lastChild === path.getNode();\n}\n\nexport function trimTextNodeLeft(node: TextNode): void {\n\tnode.value = node.value && node.value.trimStart();\n}\n\nexport function trimTextNodeRight(node: TextNode): void {\n\tnode.value = node.value && node.value.trimEnd();\n}\n\n// export function findLastIndex<T>(isMatch: (item: T, idx: number) => boolean, items: T[]) {\n//   for (let i = items.length - 1; i >= 0; i--) {\n//     if (isMatch(items[i], i)) {\n//       return i;\n//     }\n//   }\n\n//   return -1;\n// }\n\n/**\n * Remove all leading whitespace up until the first non-empty text node,\n * and all trailing whitepsace from the last non-empty text node onwards.\n */\n// export function trimChildren(children: anyNode[]) {\n//   // export function trimChildren(children: anyNode[], path: AstPath<anyNode>) {\n//   let firstNonEmptyNode = children.findIndex((n) => !isEmptyTextNode(n));\n//   // let firstNonEmptyNode = children.findIndex((n) => !isEmptyTextNode(n) && !doesEmbedStartAfterNode(n, path));\n//   firstNonEmptyNode = firstNonEmptyNode === -1 ? children.length - 1 : firstNonEmptyNode;\n\n//   let lastNonEmptyNode = findLastIndex((n, idx) => {\n//     // Last node is ok to end at the start of an embedded region,\n//     // if it's not a comment (which should stick to the region)\n//     return !isEmptyTextNode(n);\n//     // return !isEmptyTextNode(n) && ((idx === children.length - 1 && n.type !== 'Comment') || !doesEmbedStartAfterNode(n, path));\n//   }, children);\n//   lastNonEmptyNode = lastNonEmptyNode === -1 ? 0 : lastNonEmptyNode;\n\n//   for (let i = 0; i <= firstNonEmptyNode; i++) {\n//     const n = children[i];\n//     if (isTextNode(n)) {\n//       trimTextNodeLeft(n);\n//     }\n//   }\n\n//   for (let i = children.length - 1; i >= lastNonEmptyNode; i--) {\n//     const n = children[i];\n//     if (isTextNode(n)) {\n//       trimTextNodeRight(n);\n//     }\n//   }\n// }\n\n/**\n * Returns siblings, that is, the children of the parent.\n */\n// export function getSiblings(path: AstPath): anyNode[] {\n//   let parent = path.getParentNode();\n//   if (!parent) return [];\n\n//   if (isRootNode(parent)) {\n//     parent = parent.html;\n//   }\n\n//   return getChildren(parent);\n// }\n\n/**\n * Did there use to be any embedded object (that has been snipped out of the AST to be moved)\n * at the specified position?\n */\n// function doesEmbedStartAfterNode(node: anyNode, path: AstPath<anyNode>, siblings = getSiblings(path)): boolean {\n//   // If node is not at the top level of html, an embed cannot start after it,\n//   // because embeds are only at the top level\n//   if (!isNodeTopLevelHTML(node, path)) {\n//     return false;\n//   }\n\n//   const position = node.end;\n//   const root = path.stack[0];\n\n//   const embeds = [root.module, root.html, root.css];\n\n//   const nextNode = siblings[siblings.indexOf(node) + 1];\n//   return embeds.find((n) => n && n.start >= position && (!nextNode || n.end <= nextNode.start));\n// }\n\n// function isNodeTopLevelHTML(node: anyNode, path: AstPath<anyNode>) {\n//   const root = path.stack[0];\n//   return !!root.html && !!root.html.children && root.html.children.includes(node);\n// }\n\n/**\n * Check if doc is a hardline.\n * We can't just rely on a simple equality check because the doc could be created with another\n * runtime version of prettier than what we import, making a reference check fail.\n */\n\n// function isHardline(docToCheck: Doc): boolean {\n//   return docToCheck === doc.builders.hardline || deepEqual(docToCheck, doc.builders.hardline);\n// }\n\n/**\n * Simple deep equal function which suits our needs. Only works properly on POJOs without cyclic deps.\n */\n// function deepEqual(x: any, y: any): boolean {\n//   if (x === y) {\n//     return true;\n//   } else if (typeof x == 'object' && x != null && typeof y == 'object' && y != null) {\n//     if (Object.keys(x).length != Object.keys(y).length) return false;\n\n//     for (var prop in x) {\n//       if (Object.prototype.hasOwnProperty.call(y, prop)) {\n//         if (!deepEqual(x[prop], y[prop])) return false;\n//       } else {\n//         return false;\n//       }\n//     }\n\n//     return true;\n//   } else {\n//     return false;\n//   }\n// }\n\n// export function isLine(docToCheck: Doc): boolean {\n//   return (\n//     isHardline(docToCheck) ||\n//     (typeof docToCheck === 'object' && isDocCommand(docToCheck) && docToCheck.type === 'line') ||\n//     (typeof docToCheck === 'object' && isDocCommand(docToCheck) && docToCheck.type === 'concat' && docToCheck.parts.every(isLine))\n//   );\n// }\n\n/**\n * Check if the doc is empty, i.e. consists of nothing more than empty strings (possibly nested).\n */\n// export function isEmptyDoc(doc: Doc): boolean {\n//   if (typeof doc === 'string') {\n//     return doc.length === 0;\n//   }\n\n//   // if (doc.type === 'line') {\n//   //   return !doc.keepIfLonely;\n//   // }\n\n//   // Since Prettier 2.3.0, concats are represented as flat arrays\n//   if (Array.isArray(doc)) {\n//     return doc.length === 0;\n//   }\n\n//   // const { contents } = doc;\n\n//   // if (contents) {\n//   //   return isEmptyDoc(contents);\n//   // }\n\n//   // const { parts } = doc;\n\n//   // if (parts) {\n//   //   return isEmptyGroup(parts);\n//   // }\n\n//   return false;\n// }\n\n// function isEmptyGroup(group: any) {\n//   return !group.find((doc: any) => !isEmptyDoc(doc));\n// }\n\n/**\n * Trims both leading and trailing nodes matching `isWhitespace` independent of nesting level\n * (though all trimmed adjacent nodes need to be a the same level). Modifies the `docs` array.\n */\n// export function trim(docs: Doc[], isWhitespace: (doc: Doc) => boolean): Doc[] {\n//   trimLeft(docs, isWhitespace);\n//   trimRight(docs, isWhitespace);\n\n//   return docs;\n// }\n\n/**\n * Trims the leading nodes matching `isWhitespace` independent of nesting level (though all nodes need to be a the same level).\n * If there are empty docs before the first whitespace, they are removed, too.\n */\n// function trimLeft(group: Doc[], isWhitespace: (doc: Doc) => boolean): void {\n//   let firstNonWhitespace = group.findIndex((doc) => !isEmptyDoc(doc) && !isWhitespace(doc));\n\n//   if (firstNonWhitespace < 0 && group.length) {\n//     firstNonWhitespace = group.length;\n//   }\n\n//   if (firstNonWhitespace > 0) {\n//     const removed = group.splice(0, firstNonWhitespace);\n//     if (removed.every(isEmptyDoc)) {\n//       return trimLeft(group, isWhitespace);\n//     }\n//   } else {\n//     const parts = getParts(group[0]);\n\n//     if (parts) {\n//       return trimLeft(parts, isWhitespace);\n//     }\n//   }\n// }\n\n/**\n * Trims the trailing nodes matching `isWhitespace` independent of nesting level (though all nodes need to be a the same level).\n * If there are empty docs after the last whitespace, they are removed, too.\n */\n// function trimRight(group: Doc[], isWhitespace: (doc: Doc) => boolean): void {\n//   let lastNonWhitespace = group.length ? findLastIndex((doc: any) => !isEmptyDoc(doc) && !isWhitespace(doc), group) : 0;\n\n//   if (lastNonWhitespace < group.length - 1) {\n//     const removed = group.splice(lastNonWhitespace + 1);\n//     if (removed.every(isEmptyDoc)) {\n//       return trimRight(group, isWhitespace);\n//     }\n//   } else {\n//     const parts = getParts(group[group.length - 1]);\n\n//     if (parts) {\n//       return trimRight(parts, isWhitespace);\n//     }\n//   }\n// }\n\n// function getParts(doc: Doc): Doc[] | undefined {\n//   if (typeof doc === 'object') {\n//     // Since Prettier 2.3.0, concats are represented as flat arrays\n//     if (Array.isArray(doc)) {\n//       return doc;\n//     }\n//     if (doc.type === 'fill' || doc.type === 'concat') {\n//       return doc.parts;\n//     }\n//     if (doc.type === 'group') {\n//       return getParts(doc.contents);\n//     }\n//   }\n// }\n\n// export const isObjEmpty = (obj: object): boolean => {\n//   for (let i in obj) return false;\n//   return true;\n// };\n\n/** Shallowly attach comments to children */\n// export function attachCommentsHTML(node: anyNode): void {\n//   if (!isNodeWithChildren(node) || !node.children.some(({ type }) => type === 'Comment')) return;\n\n//   const nodesToRemove = [];\n\n//   // note: the .length - 1 is because we don’t need to read the last node\n//   for (let n = 0; n < node.children.length - 1; n++) {\n//     if (!node.children[n]) continue;\n\n//     // attach comment to the next non-whitespace node\n//     if (node.children[n].type === 'Comment') {\n//       let next = n + 1;\n//       while (isEmptyTextNode(node.children[next])) {\n//         nodesToRemove.push(next); // if arbitrary whitespace between comment and node, remove\n//         next++; // skip to the next non-whitespace node\n//       }\n//       const commentNode = node.children[next];\n//       if (commentNode) {\n//         const comment = node.children[n];\n//         util.addLeadingComment(commentNode, comment);\n//       }\n//     }\n//   }\n\n//   // remove arbitrary whitespace nodes\n//   nodesToRemove.reverse(); // start at back so we aren’t changing indices\n//   nodesToRemove.forEach((index) => {\n//     node.children.splice(index, 1);\n//   });\n// }\n\n/** dedent string & return tabSize (the last part is what we need) */\nexport function manualDedent(input: string): {\n\ttabSize: number;\n\tchar: string;\n\tresult: string;\n} {\n\tlet minTabSize = Infinity;\n\tlet result = input;\n\t// 1. normalize\n\tresult = result.replace(/\\r\\n/g, '\\n');\n\n\t// 2. count tabSize\n\tlet char = '';\n\tfor (const line of result.split('\\n')) {\n\t\tif (!line) continue;\n\t\t// if any line begins with a non-whitespace char, minTabSize is 0\n\t\tif (line[0] && /^[^\\s]/.test(line[0])) {\n\t\t\tminTabSize = 0;\n\t\t\tbreak;\n\t\t}\n\t\tconst match = line.match(/^(\\s+)\\S+/); // \\S ensures we don’t count lines of pure whitespace\n\t\tif (match) {\n\t\t\tif (match[1] && !char) char = match[1][0];\n\t\t\tif (match[1].length < minTabSize) minTabSize = match[1].length;\n\t\t}\n\t}\n\n\t// 3. reformat string\n\tif (minTabSize > 0 && Number.isFinite(minTabSize)) {\n\t\tresult = result.replace(new RegExp(`^${new Array(minTabSize + 1).join(char)}`, 'gm'), '');\n\t}\n\n\treturn {\n\t\ttabSize: minTabSize === Infinity ? 0 : minTabSize,\n\t\tchar,\n\t\tresult,\n\t};\n}\n\n/** re-indent string by chars */\n// export function indent(input: string, char: string = ' '): string {\n//   return input.replace(/^(.)/gm, `${char}$1`);\n// }\n\n/** scan code for Markdown name(s) */\nexport function getMarkdownName(script: string): Set<string> {\n\t// default import: could be named anything\n\tlet defaultMatch;\n\twhile (\n\t\t(defaultMatch = /import\\s+([^\\s]+)\\s+from\\s+['|\"|`]astro\\/components\\/Markdown\\.astro/g.exec(\n\t\t\tscript\n\t\t))\n\t) {\n\t\tif (defaultMatch[1]) return new Set([defaultMatch[1].trim()]);\n\t}\n\n\t// named component: must have \"Markdown\" in specifier, but can be renamed via \"as\"\n\tlet namedMatch;\n\twhile ((namedMatch = /import\\s+\\{\\s*([^}]+)\\}\\s+from\\s+['|\"|`]astro\\/components/g.exec(script))) {\n\t\tif (namedMatch[1] && !namedMatch[1].includes('Markdown')) continue;\n\t\t// if \"Markdown\" was imported, find out whether or not it was renamed\n\t\tconst rawImports = namedMatch[1].trim().replace(/^\\{/, '').replace(/\\}$/, '').trim();\n\t\tlet importName = 'Markdown';\n\t\tfor (const spec of rawImports.split(',')) {\n\t\t\tconst [original, renamed] = spec.split(' as ').map((s) => s.trim());\n\t\t\tif (original !== 'Markdown') continue;\n\t\t\timportName = renamed || original;\n\t\t\tbreak;\n\t\t}\n\t\treturn new Set([importName]);\n\t}\n\treturn new Set(['Markdown']);\n}\n\n// TODO: USE THE COMPILER\n/** True if the node is of type text */\nexport function isTextNode(node: anyNode): node is TextNode {\n\treturn node.type === 'text';\n}\n\n// export function isMustacheNode(node: anyNode): node is MustacheTagNode {\n//   return node.type === 'MustacheTag';\n// }\n\n// export function isDocCommand(doc: Doc): doc is doc.builders.DocCommand {\n//   if (typeof doc === 'string') return false;\n//   if (Array.isArray(doc)) return false;\n//   return true;\n// }\n\nexport function isInsideQuotedAttribute(path: AstPath): boolean {\n\tconst stack = path.stack as anyNode[];\n\treturn stack.some((node) => node.type === 'attribute' && !isLoneMustacheTag(node));\n}\n\n/**\n * Currently, the compiler has a bug that duplicates text nodes when no\n *  TagLikeNode elements are present.\n */\nexport function removeDuplicates(root: RootNode) {\n\troot.children = root.children.filter((node, i, rootChildren) => {\n\t\tif (node.type !== 'text') return true;\n\t\t// https://stackoverflow.com/questions/2218999/how-to-remove-all-duplicates-from-an-array-of-objects\n\t\treturn (\n\t\t\ti ===\n\t\t\trootChildren.findIndex((t) => {\n\t\t\t\tif (t.position && node.position) {\n\t\t\t\t\treturn (\n\t\t\t\t\t\tnode.type === 'text' &&\n\t\t\t\t\t\tt.position.start.offset === node.position.start.offset &&\n\t\t\t\t\t\tt.position.start.line === node.position.start.line &&\n\t\t\t\t\t\tt.position.start.column === node.position.start.column\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\t});\n}\n\n/** True if the node is TagLikeNode:\n *\n * ElementNode | ComponentNode | CustomElementNode | FragmentNode */\nexport function isTagLikeNode(node: anyNode): node is TagLikeNode {\n\treturn (\n\t\tnode.type === 'element' ||\n\t\tnode.type === 'component' ||\n\t\tnode.type === 'custom-element' ||\n\t\tnode.type === 'fragment'\n\t);\n}\n\n/**\n * Returns siblings, that is, the children of the parent.\n */\nexport function getSiblings(path: AstPath): anyNode[] {\n\tconst parent = path.getParentNode();\n\tif (!parent) return [];\n\n\treturn getChildren(parent);\n}\n\nexport function getNextNode(path: AstPath): anyNode | null {\n\tconst node = path.getNode();\n\tif (node) {\n\t\tconst siblings = getSiblings(path);\n\t\tif (node.position?.start === siblings[siblings.length - 1].position?.start) return null;\n\t\tfor (let i = 0; i < siblings.length; i++) {\n\t\t\tconst sibling = siblings[i];\n\t\t\tif (sibling.position?.start === node.position?.start && i !== siblings.length - 1) {\n\t\t\t\treturn siblings[i + 1];\n\t\t\t}\n\t\t}\n\t}\n\treturn null;\n}\n","import {\n\tAstPath as AstP,\n\tBuiltInParsers,\n\tDoc,\n\tParserOptions as ParserOpts,\n\tPrinter,\n} from 'prettier';\nimport _doc from 'prettier/doc';\nconst {\n\tbuilders: {\n\t\tbreakParent,\n\t\tdedent,\n\t\tfill,\n\t\tgroup,\n\t\thardline,\n\t\tindent,\n\t\tjoin,\n\t\tline,\n\t\tliteralline,\n\t\tsoftline,\n\t},\n\tutils: { removeLines, stripTrailingHardline },\n} = _doc;\nimport { SassFormatter, SassFormatterConfig } from 'sass-formatter';\n\nimport { parseSortOrder } from './options';\n\nimport {\n\tRootNode,\n\tNode,\n\tAttributeNode,\n\tCommentNode,\n\tNodeWithText,\n\tselfClosingTags,\n\tTextNode,\n\tanyNode,\n} from './nodes';\n\ntype ParserOptions = ParserOpts<anyNode>;\ntype AstPath = AstP<anyNode>;\n\nimport {\n\t// attachCommentsHTML,\n\tcanOmitSoftlineBeforeClosingTag,\n\tmanualDedent,\n\tendsWithLinebreak,\n\tforceIntoExpression,\n\tformattableAttributes,\n\tgetMarkdownName,\n\tgetText,\n\tgetUnencodedText,\n\tisRootNode,\n\t// isDocCommand,\n\t// isEmptyDoc,\n\tisEmptyTextNode,\n\tisInlineElement,\n\tisInsideQuotedAttribute,\n\t// isLine,\n\tisLoneMustacheTag,\n\t// isNodeWithChildren,\n\tisOrCanBeConvertedToShorthand,\n\tisPreTagContent,\n\tisShorthandAndMustBeConvertedToBinaryExpression,\n\tisTextNode,\n\tisTextNodeEndingWithWhitespace,\n\tisTextNodeStartingWithLinebreak,\n\tisTextNodeStartingWithWhitespace,\n\tprintRaw,\n\t// replaceEndOfLineWith,\n\tshouldHugEnd,\n\tshouldHugStart,\n\tstartsWithLinebreak,\n\t// trim,\n\t// trimChildren,\n\ttrimTextNodeLeft,\n\ttrimTextNodeRight,\n\tremoveDuplicates,\n\tgetNextNode,\n\tisTagLikeNode,\n} from './utils';\n\n// function printTopLevelParts(node: RootNode, path: AstPath, opts: ParserOptions, print: printFn): Doc {\n//   let docs = [];\n\n//   const normalize = (doc: Doc) => [stripTrailingHardline(doc), hardline];\n\n//   // frontmatter always comes first\n//   if (node.module) {\n//     const subDoc = normalize(path.call(print, 'module'));\n//     docs.push(subDoc);\n//   }\n\n//   // markup and styles follow, whichever the user prefers (default: markup, styles)\n//   for (const section of parseSortOrder(opts.astroSortOrder)) {\n//     switch (section) {\n//       case 'markup': {\n//         const subDoc = path.call(print, 'html');\n//         if (!isEmptyDoc(subDoc)) docs.push(normalize(subDoc));\n//         break;\n//       }\n//       case 'styles': {\n//         const subDoc = path.call(print, 'css');\n//         if (!isEmptyDoc(subDoc)) docs.push(normalize(subDoc));\n//         break;\n//       }\n//     }\n//   }\n\n//   return join(softline, docs);\n// }\n\n// function printAttributeNodeValue(path: AstPath, print: printFn, quotes: boolean, node: AttributeNode): Doc[] | _doc.builders.Indent {\n//   const valueDocs = path.map((childPath) => childPath.call(print), 'value');\n\n//   if (!quotes || !formattableAttributes.includes(node.name)) {\n//     return valueDocs;\n//   } else {\n//     return indent(group(trim(valueDocs, isLine)));\n//   }\n// }\n\n// TODO: USE ASTPATH GENERIC\n// function printJS(path: AstP, print: printFn, name: string, { forceSingleQuote, forceSingleLine }: { forceSingleQuote: boolean; forceSingleLine: boolean }) {\n//   path.getValue()[name].isJS = true;\n//   path.getValue()[name].forceSingleQuote = forceSingleQuote;\n//   path.getValue()[name].forceSingleLine = forceSingleLine;\n//   return path.call(print, name);\n// }\n\n// TODO: MAYBE USE THIS TO HANDLE COMMENTS\nfunction printComment(commentPath: AstPath, options: ParserOptions): Doc {\n\t// note(drew): this isn’t doing anything currently, but Prettier requires it anyway\n\t// @ts-ignore\n\treturn commentPath;\n}\n\nexport type printFn = (path: AstPath) => Doc;\n\n// eslint-disable-next-line @typescript-eslint/no-shadow\nfunction print(path: AstPath, opts: ParserOptions, print: printFn): Doc {\n\tconst node = path.getValue();\n\t// const isMarkdownSubDoc = opts.parentParser === 'markdown'; // is this a code block within .md?\n\n\t// 1. handle special node types\n\tif (!node) {\n\t\treturn '';\n\t}\n\n\tif (typeof node === 'string') {\n\t\treturn node;\n\t}\n\n\t// if (Array.isArray(node)) {\n\t//   return path.map((childPath) => childPath.call(print));\n\t// }\n\n\t// if (isASTNode(node)) {\n\t//   return printTopLevelParts(node, path, opts, print);\n\t// }\n\n\t// 2. attach comments shallowly to children, if any (https://prettier.io/docs/en/plugins.html#manually-attaching-a-comment)\n\t// if (!isPreTagContent(path) && !isMarkdownSubDoc && node.type === 'Fragment') {\n\t//   attachCommentsHTML(node);\n\t// }\n\n\t// 3. handle printing\n\tswitch (node.type) {\n\t\tcase 'root': {\n\t\t\tremoveDuplicates(node);\n\t\t\treturn [stripTrailingHardline(path.map(print, 'children')), hardline];\n\t\t}\n\n\t\t// case 'Fragment': {\n\t\t//   const text = getText(node, opts);\n\t\t//   if (text.length === 0) {\n\t\t//     return '';\n\t\t//   }\n\n\t\t//   if (!isNodeWithChildren(node) || node.children.every(isEmptyTextNode)) return '';\n\n\t\t//   if (!isPreTagContent(path)) {\n\t\t//     trimChildren(node.children);\n\t\t//     const output = trim(\n\t\t//       [path.map(print, 'children')],\n\t\t//       (n) =>\n\t\t//         isLine(n) ||\n\t\t//         (typeof n === 'string' && n.trim() === '') ||\n\t\t//         // Because printChildren may append this at the end and\n\t\t//         // may hide other lines before it\n\t\t//         n === breakParent\n\t\t//     );\n\t\t//     if (output.every((doc) => isEmptyDoc(doc))) {\n\t\t//       return '';\n\t\t//     }\n\t\t//     return group([...output, hardline]);\n\t\t//   } else {\n\t\t//     return group(path.map(print, 'children'));\n\t\t//   }\n\t\t// }\n\t\tcase 'text': {\n\t\t\tconst rawText = getUnencodedText(node);\n\n\t\t\t// TODO: TEST PRE TAGS\n\t\t\t// if (isPreTagContent(path)) {\n\t\t\t//   if (path.getParentNode()?.type === 'Attribute') {\n\t\t\t//     // Direct child of attribute value -> add literallines at end of lines\n\t\t\t//     // so that other things don't break in unexpected places\n\t\t\t//     return replaceEndOfLineWith(rawText, literalline);\n\t\t\t//   }\n\t\t\t//   return rawText;\n\t\t\t// }\n\n\t\t\tif (isEmptyTextNode(node)) {\n\t\t\t\tconst hasWhiteSpace = rawText.trim().length < getUnencodedText(node).length;\n\t\t\t\tconst hasOneOrMoreNewlines = /\\n/.test(getUnencodedText(node));\n\t\t\t\tconst hasTwoOrMoreNewlines = /\\n\\r?\\s*\\n\\r?/.test(getUnencodedText(node));\n\t\t\t\tif (hasTwoOrMoreNewlines) {\n\t\t\t\t\treturn [hardline, hardline];\n\t\t\t\t}\n\t\t\t\tif (hasOneOrMoreNewlines) {\n\t\t\t\t\treturn hardline;\n\t\t\t\t}\n\t\t\t\tif (hasWhiteSpace) {\n\t\t\t\t\treturn line;\n\t\t\t\t}\n\t\t\t\treturn '';\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * For non-empty text nodes each sequence of non-whitespace characters (effectively,\n\t\t\t * each \"word\") is joined by a single `line`, which will be rendered as a single space\n\t\t\t * until this node's current line is out of room, at which `fill` will break at the\n\t\t\t * most convenient instance of `line`.\n\t\t\t */\n\t\t\treturn fill(splitTextToDocs(node));\n\t\t}\n\n\t\t// case 'InlineComponent':\n\t\t// case 'Slot':\n\t\tcase 'component':\n\t\tcase 'fragment':\n\t\tcase 'element': {\n\t\t\t// const isEmpty = node.children?.every((child) => isEmptyTextNode(child));\n\t\t\tlet isEmpty: boolean;\n\t\t\tif (!node.children) {\n\t\t\t\tisEmpty = true;\n\t\t\t} else {\n\t\t\t\tisEmpty = node.children.every((child) => isEmptyTextNode(child));\n\t\t\t}\n\t\t\tconst isSelfClosingTag =\n\t\t\t\tisEmpty && (node.type !== 'element' || selfClosingTags.indexOf(node.name) !== -1);\n\n\t\t\tconst attributes = path.map(print, 'attributes');\n\t\t\tif (isSelfClosingTag) {\n\t\t\t\treturn group(['<', node.name, indent(group(attributes)), line, `/>`]);\n\t\t\t\t// return group(['<', node.name, indent(group([...attributes, opts.jsxBracketNewLine ? dedent(line) : ''])), ...[opts.jsxBracketNewLine ? '' : ' ', `/>`]]);\n\t\t\t}\n\n\t\t\tif (node.children) {\n\t\t\t\tconst children = node.children;\n\t\t\t\tconst firstChild = children[0];\n\t\t\t\tconst lastChild = children[children.length - 1];\n\n\t\t\t\t// No hugging of content means it's either a block element and/or there's whitespace at the start/end\n\t\t\t\tlet noHugSeparatorStart:\n\t\t\t\t\t| _doc.builders.Concat\n\t\t\t\t\t| _doc.builders.Line\n\t\t\t\t\t| _doc.builders.Softline\n\t\t\t\t\t| string = softline;\n\t\t\t\tlet noHugSeparatorEnd:\n\t\t\t\t\t| _doc.builders.Concat\n\t\t\t\t\t| _doc.builders.Line\n\t\t\t\t\t| _doc.builders.Softline\n\t\t\t\t\t| string = softline;\n\t\t\t\tconst hugStart = shouldHugStart(node, opts);\n\t\t\t\tconst hugEnd = shouldHugEnd(node, opts);\n\n\t\t\t\tlet body;\n\n\t\t\t\tif (isEmpty) {\n\t\t\t\t\tbody =\n\t\t\t\t\t\tisInlineElement(path, opts, node) &&\n\t\t\t\t\t\tnode.children.length &&\n\t\t\t\t\t\tisTextNodeStartingWithWhitespace(node.children[0]) &&\n\t\t\t\t\t\t!isPreTagContent(path)\n\t\t\t\t\t\t\t? () => line\n\t\t\t\t\t\t\t: // () => (opts.jsxBracketNewLine ? '' : softline);\n\t\t\t\t\t\t\t  () => softline;\n\t\t\t\t} else if (isPreTagContent(path)) {\n\t\t\t\t\tbody = () => printRaw(node);\n\t\t\t\t} else if (isInlineElement(path, opts, node) && !isPreTagContent(path)) {\n\t\t\t\t\tbody = () => path.map(print, 'children');\n\t\t\t\t} else {\n\t\t\t\t\tbody = () => path.map(print, 'children');\n\t\t\t\t}\n\n\t\t\t\tconst openingTag = [\n\t\t\t\t\t'<',\n\t\t\t\t\tnode.name,\n\t\t\t\t\tindent(\n\t\t\t\t\t\tgroup([\n\t\t\t\t\t\t\t...attributes,\n\t\t\t\t\t\t\thugStart\n\t\t\t\t\t\t\t\t? ''\n\t\t\t\t\t\t\t\t: !isPreTagContent(path) && !opts.bracketSameLine\n\t\t\t\t\t\t\t\t? dedent(softline)\n\t\t\t\t\t\t\t\t: '',\n\t\t\t\t\t\t])\n\t\t\t\t\t),\n\t\t\t\t];\n\t\t\t\t// const openingTag = ['<', node.name, indent(group([...attributes, hugStart ? '' : opts.jsxBracketNewLine && !isPreTagContent(path) ? dedent(softline) : '']))];\n\n\t\t\t\tif (hugStart && hugEnd) {\n\t\t\t\t\tconst huggedContent = [softline, group(['>', body(), `</${node.name}`])];\n\n\t\t\t\t\tconst omitSoftlineBeforeClosingTag =\n\t\t\t\t\t\tisEmpty || canOmitSoftlineBeforeClosingTag(path, opts);\n\t\t\t\t\t// const omitSoftlineBeforeClosingTag = (isEmpty && opts.jsxBracketNewLine) || canOmitSoftlineBeforeClosingTag(node, path, opts);\n\t\t\t\t\treturn group([\n\t\t\t\t\t\t...openingTag,\n\t\t\t\t\t\tisEmpty ? group(huggedContent) : group(indent(huggedContent)),\n\t\t\t\t\t\tomitSoftlineBeforeClosingTag ? '' : softline,\n\t\t\t\t\t\t'>',\n\t\t\t\t\t]);\n\t\t\t\t}\n\n\t\t\t\tif (isPreTagContent(path)) {\n\t\t\t\t\tnoHugSeparatorStart = '';\n\t\t\t\t\tnoHugSeparatorEnd = '';\n\t\t\t\t} else {\n\t\t\t\t\tlet didSetEndSeparator = false;\n\n\t\t\t\t\tif (!hugStart && firstChild && isTextNode(firstChild)) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tisTextNodeStartingWithLinebreak(firstChild) &&\n\t\t\t\t\t\t\tfirstChild !== lastChild &&\n\t\t\t\t\t\t\t(!isInlineElement(path, opts, node) || isTextNodeEndingWithWhitespace(lastChild))\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tnoHugSeparatorStart = hardline;\n\t\t\t\t\t\t\tnoHugSeparatorEnd = hardline;\n\t\t\t\t\t\t\tdidSetEndSeparator = true;\n\t\t\t\t\t\t} else if (isInlineElement(path, opts, node)) {\n\t\t\t\t\t\t\tnoHugSeparatorStart = line;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttrimTextNodeLeft(firstChild);\n\t\t\t\t\t}\n\t\t\t\t\tif (!hugEnd && lastChild && isTextNode(lastChild)) {\n\t\t\t\t\t\tif (isInlineElement(path, opts, node) && !didSetEndSeparator) {\n\t\t\t\t\t\t\tnoHugSeparatorEnd = softline;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttrimTextNodeRight(lastChild);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (hugStart) {\n\t\t\t\t\treturn group([\n\t\t\t\t\t\t...openingTag,\n\t\t\t\t\t\tindent([softline, group(['>', body()])]),\n\t\t\t\t\t\tnoHugSeparatorEnd,\n\t\t\t\t\t\t`</${node.name}>`,\n\t\t\t\t\t]);\n\t\t\t\t}\n\n\t\t\t\tif (hugEnd) {\n\t\t\t\t\treturn group([\n\t\t\t\t\t\t...openingTag,\n\t\t\t\t\t\t'>',\n\t\t\t\t\t\tindent([noHugSeparatorStart, group([body(), `</${node.name}`])]),\n\t\t\t\t\t\tcanOmitSoftlineBeforeClosingTag(path, opts) ? '' : softline,\n\t\t\t\t\t\t'>',\n\t\t\t\t\t]);\n\t\t\t\t}\n\n\t\t\t\tif (isEmpty) {\n\t\t\t\t\treturn group([...openingTag, '>', body(), `</${node.name}>`]);\n\t\t\t\t}\n\n\t\t\t\treturn group([\n\t\t\t\t\t...openingTag,\n\t\t\t\t\t'>',\n\t\t\t\t\tindent([noHugSeparatorStart, body()]),\n\t\t\t\t\tnoHugSeparatorEnd,\n\t\t\t\t\t`</${node.name}>`,\n\t\t\t\t]);\n\t\t\t}\n\t\t\t// TODO: WIP\n\t\t\treturn '';\n\t\t}\n\t\t// case 'AttributeShorthand': {\n\t\t//   return node.expression.name;\n\t\t// }\n\t\tcase 'attribute': {\n\t\t\tconst name = node.name.trim();\n\t\t\tconst quote = opts.singleQuote ? \"'\" : '\"';\n\t\t\tswitch (node.kind) {\n\t\t\t\tcase 'empty':\n\t\t\t\t\treturn [line, name];\n\t\t\t\tcase 'expression':\n\t\t\t\t\t// HANDLED IN EMBED FUNCION\n\t\t\t\t\treturn '';\n\t\t\t\tcase 'quoted':\n\t\t\t\t\treturn [line, name, '=', quote, node.value, quote];\n\t\t\t\tcase 'shorthand':\n\t\t\t\t\treturn [line, '{', name, '}'];\n\t\t\t\tcase 'spread':\n\t\t\t\t\treturn [line, '{...', name, '}'];\n\t\t\t\tcase 'template-literal':\n\t\t\t\t\treturn [line, name, '=', '`', node.value, '`'];\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn '';\n\t\t}\n\n\t\tcase 'doctype': {\n\t\t\t// https://www.w3.org/wiki/Doctypes_and_markup_styles\n\t\t\treturn ['<!DOCTYPE html>', hardline];\n\t\t}\n\t\t// case 'Expression':\n\t\t//   // missing test ?\n\t\t//   return [];\n\t\t// case 'MustacheTag':\n\t\t//   return [\n\t\t//     '{',\n\t\t//     printJS(path, print, 'expression', {\n\t\t//       forceSingleLine: isInsideQuotedAttribute(path),\n\t\t//       forceSingleQuote: opts.jsxSingleQuote,\n\t\t//     }),\n\t\t//     '}',\n\t\t//   ];\n\t\t// case 'Spread':\n\t\t//   return [\n\t\t//     line,\n\t\t//     '{...',\n\t\t//     printJS(path, print, 'expression', {\n\t\t//       forceSingleQuote: true,\n\t\t//       forceSingleLine: false,\n\t\t//     }),\n\t\t//     '}',\n\t\t//   ];\n\t\tcase 'comment':\n\t\t\tconst nextNode = getNextNode(path);\n\t\t\tlet trailingLine: _doc.builders.Concat | string = '';\n\t\t\tif (nextNode && isTagLikeNode(nextNode)) {\n\t\t\t\ttrailingLine = hardline;\n\t\t\t}\n\t\t\treturn ['<!--', getUnencodedText(node), '-->', trailingLine];\n\t\t// case 'CodeSpan':\n\t\t//   return getUnencodedText(node);\n\t\t// case 'CodeFence': {\n\t\t//   console.debug(node);\n\t\t//   // const lang = node.metadata.slice(3);\n\t\t//   return [node.metadata, hardline, /** somehow call textToDoc(lang),  */ node.data, hardline, '```', hardline];\n\n\t\t//   // We should use `node.metadata` to select a parser to embed with... something like return [node.metadata, hardline textToDoc(node.getMetadataLanguage()), hardline, `\\`\\`\\``];\n\t\t// }\n\t\tdefault: {\n\t\t\tthrow new Error(`Unhandled node type \"${node.type}\"!`);\n\t\t}\n\t}\n}\n\n/**\n * Split the text into words separated by whitespace. Replace the whitespaces by lines,\n * collapsing multiple whitespaces into a single line.\n *\n * If the text starts or ends with multiple newlines, two of those should be kept.\n */\nfunction splitTextToDocs(node: NodeWithText): Doc[] {\n\tconst text = getUnencodedText(node);\n\n\tconst textLines = text.split(/[\\t\\n\\f\\r ]+/);\n\n\tlet docs = join(line, textLines).parts.filter((s) => s !== '');\n\n\tif (startsWithLinebreak(text)) {\n\t\tdocs[0] = hardline;\n\t}\n\tif (startsWithLinebreak(text, 2)) {\n\t\tdocs = [hardline, ...docs];\n\t}\n\n\tif (endsWithLinebreak(text)) {\n\t\tdocs[docs.length - 1] = hardline;\n\t}\n\tif (endsWithLinebreak(text, 2)) {\n\t\tdocs = [...docs, hardline];\n\t}\n\n\treturn docs;\n}\n\nfunction expressionParser(text: string, parsers: BuiltInParsers, opts: ParserOptions) {\n\tconst ast = parsers.babel(text, opts);\n\t// const ast = parsers.babel(text, parsers, opts);\n\n\treturn {\n\t\t...ast,\n\t\tprogram: ast.program.body[0].expression.children[0].expression,\n\t};\n}\n\nlet markdownComponentName = new Set();\n\nfunction embed(\n\tpath: AstPath,\n\t// eslint-disable-next-line @typescript-eslint/no-shadow\n\tprint: printFn,\n\ttextToDoc: (text: string, options: object) => Doc,\n\topts: ParserOptions\n) {\n\t// TODO: ADD TYPES OR FIND ANOTHER WAY TO ACHIVE THIS\n\t// @ts-ignore\n\tif (!opts.__astro) opts.__astro = {};\n\n\tconst node = path.getValue();\n\n\tif (!node) return null;\n\n\tif (node.type === 'expression') {\n\t\tconst textContent = printRaw(node);\n\n\t\tlet content: Doc;\n\n\t\tcontent = textToDoc(forceIntoExpression(textContent), {\n\t\t\t...opts,\n\t\t\tparser: expressionParser,\n\t\t\tsemi: false,\n\t\t});\n\t\tcontent = stripTrailingHardline(content);\n\n\t\t// if (node.children[0].value) {\n\t\t//   content = textToDoc(forceIntoExpression(textContent), { parser: expressionParser });\n\t\t// } else {\n\t\t//   content = textToDoc(forceIntoExpression(node.children[0].value), { parser: expressionParser });\n\t\t// }\n\t\treturn [\n\t\t\t'{',\n\t\t\t// printJS(path, print, 'expression', {\n\t\t\t//   forceSingleLine: isInsideQuotedAttribute(path),\n\t\t\t//   forceSingleQuote: opts.jsxSingleQuote,\n\t\t\t// }),\n\t\t\tcontent,\n\t\t\t'}',\n\t\t];\n\t}\n\n\t// ATTRIBUTE WITH EXPRESSION AS VALUE\n\tif (node.type === 'attribute' && node.kind === 'expression') {\n\t\tconst value = node.value.trim();\n\t\tconst name = node.name.trim();\n\t\tlet attrNodeValue = textToDoc(forceIntoExpression(value), {\n\t\t\t...opts,\n\t\t\tparser: expressionParser,\n\t\t\tsemi: false,\n\t\t});\n\t\tattrNodeValue = stripTrailingHardline(attrNodeValue);\n\t\t// if (Array.isArray(attrNodeValue) && attrNodeValue[0] === ';') {\n\t\t//   attrNodeValue = attrNodeValue.slice(1);\n\t\t// }\n\t\tif (name === value && opts.astroAllowShorthand) {\n\t\t\treturn [line, '{', attrNodeValue, '}'];\n\t\t}\n\t\treturn [line, name, '=', '{', attrNodeValue, '}'];\n\t}\n\n\t// TODO: ADD TYPES OR FIND ANOTHER WAY TO ACHIVE THIS\n\t// @ts-ignore\n\t// if (node.isJS) {\n\t//   try {\n\t//     const embeddedopts = {\n\t//       parser: expressionParser,\n\t//     };\n\t//     // TODO: ADD TYPES OR FIND ANOTHER WAY TO ACHIVE THIS\n\t//     // @ts-ignore\n\t//     if (node.forceSingleQuote) {\n\t//       // TODO: ADD TYPES OR FIND ANOTHER WAY TO ACHIVE THIS\n\t//       // @ts-ignore\n\t//       embeddedopts.singleQuote = true;\n\t//     }\n\n\t//     const docs = textToDoc(forceIntoExpression(getText(node, opts)), embeddedopts);\n\t//     // TODO: ADD TYPES OR FIND ANOTHER WAY TO ACHIVE THIS\n\t//     // @ts-ignore\n\t//     return node.forceSingleLine ? removeLines(docs) : docs;\n\t//   } catch (e) {\n\t//     return getText(node, opts);\n\t//   }\n\t// }\n\n\tif (node.type === 'frontmatter') {\n\t\tmarkdownComponentName = getMarkdownName(node.value);\n\t\treturn [\n\t\t\tgroup([\n\t\t\t\t'---',\n\t\t\t\thardline,\n\t\t\t\ttextToDoc(node.value, { ...opts, parser: 'typescript' }),\n\t\t\t\t'---',\n\t\t\t\thardline,\n\t\t\t]),\n\t\t\thardline,\n\t\t];\n\t}\n\n\t// format script element\n\tif (node.type === 'element' && node.name === 'script') {\n\t\tconst scriptContent = printRaw(node);\n\t\tlet formatttedScript = textToDoc(scriptContent, {\n\t\t\t...opts,\n\t\t\tparser: 'typescript',\n\t\t});\n\t\tformatttedScript = stripTrailingHardline(formatttedScript);\n\n\t\t// print\n\t\tconst attributes = path.map(print, 'attributes');\n\t\tconst openingTag = group(['<script', indent(group(attributes)), softline, '>']);\n\t\treturn [openingTag, indent([hardline, formatttedScript]), hardline, '</script>'];\n\t}\n\t// if (isTextNode(node)) {\n\t//   const parent = path.getParentNode();\n\n\t//   if (parent && parent.type === 'Element' && parent.name === 'script') {\n\t//     const formatttedScript = textToDoc(node.data, { ...opts, parser: 'typescript' });\n\t//     return stripTrailingHardline(formatttedScript);\n\t//   }\n\t// }\n\n\t// format style element\n\tif (node.type === 'element' && node.name === 'style') {\n\t\tconst styleTagContent = printRaw(node);\n\n\t\tconst supportedStyleLangValues = ['css', 'scss', 'sass'];\n\t\tlet parserLang = 'css';\n\n\t\tif (node.attributes) {\n\t\t\tconst langAttribute = node.attributes.filter((x) => x.name === 'lang');\n\t\t\tif (langAttribute.length) {\n\t\t\t\tconst styleLang = langAttribute[0].value.toLowerCase();\n\t\t\t\tif (supportedStyleLangValues.includes(styleLang)) parserLang = styleLang;\n\t\t\t}\n\t\t}\n\n\t\tswitch (parserLang) {\n\t\t\tcase 'css':\n\t\t\tcase 'scss': {\n\t\t\t\t// the css parser appends an extra indented hardline, which we want outside of the `indent()`,\n\t\t\t\t// so we remove the last element of the array\n\t\t\t\tlet formattedStyles = textToDoc(styleTagContent, {\n\t\t\t\t\t...opts,\n\t\t\t\t\tparser: parserLang,\n\t\t\t\t});\n\n\t\t\t\tformattedStyles = stripTrailingHardline(formattedStyles);\n\n\t\t\t\t// print\n\t\t\t\tconst attributes = path.map(print, 'attributes');\n\t\t\t\tconst openingTag = group(['<style', indent(group(attributes)), softline, '>']);\n\t\t\t\treturn [openingTag, indent([hardline, formattedStyles]), hardline, '</style>'];\n\t\t\t}\n\t\t\tcase 'sass': {\n\t\t\t\tconst lineEnding = opts.endOfLine.toUpperCase() === 'CRLF' ? 'CRLF' : 'LF';\n\t\t\t\tconst sassOptions: Partial<SassFormatterConfig> = {\n\t\t\t\t\ttabSize: opts.tabWidth,\n\t\t\t\t\tinsertSpaces: !opts.useTabs,\n\t\t\t\t\tlineEnding,\n\t\t\t\t};\n\n\t\t\t\t// dedent the .sass, otherwise SassFormatter gets indentation wrong\n\t\t\t\tconst { result: raw } = manualDedent(styleTagContent);\n\n\t\t\t\t// format\n\t\t\t\tconst formattedSassIndented = SassFormatter.Format(raw, sassOptions).trim();\n\n\t\t\t\t// print\n\t\t\t\tconst formattedSass = join(hardline, formattedSassIndented.split('\\n'));\n\t\t\t\tconst attributes = path.map(print, 'attributes');\n\t\t\t\tconst openingTag = group(['<style', indent(group(attributes)), softline, '>']);\n\t\t\t\treturn [openingTag, indent(group([hardline, formattedSass])), hardline, '</style>'];\n\t\t\t}\n\t\t}\n\t}\n\n\t// MARKDOWN COMPONENT\n\tif (node.type === 'component' && markdownComponentName.has(node.name)) {\n\t\tlet content = printRaw(node);\n\n\t\t// dedent the content\n\t\tcontent = content.replace(/\\r\\n/g, '\\n');\n\t\tconst contentArr = content.split('\\n').map((s) => s.trimStart());\n\t\tcontent = contentArr.join('\\n');\n\n\t\t// format\n\t\tlet formatttedMarkdown = textToDoc(content, {\n\t\t\t...opts,\n\t\t\tparser: 'markdown',\n\t\t});\n\t\tformatttedMarkdown = stripTrailingHardline(formatttedMarkdown);\n\n\t\t// return formatttedMarkdown;\n\t\tconst attributes = path.map(print, 'attributes');\n\t\tconst openingTag = group([`<${node.name}`, indent(group(attributes)), softline, '>']);\n\t\treturn [openingTag, indent(group([hardline, formatttedMarkdown])), hardline, `</${node.name}>`];\n\t}\n\n\treturn null;\n}\n\nfunction hasPrettierIgnore(path: AstP<CommentNode>) {\n\t// const node = path.getNode();\n\n\t// if (!node || !Array.isArray(node.comments)) return false;\n\n\t// const hasIgnore = node.comments.some(\n\t//   (comment: any) => comment.data.includes('prettier-ignore') && !comment.data.includes('prettier-ignore-start') && !comment.data.includes('prettier-ignore-end')\n\t// );\n\t// return hasIgnore;\n\treturn false;\n}\n\nconst printer: Printer = {\n\tprint,\n\tprintComment,\n\tembed,\n\thasPrettierIgnore,\n};\n\nexport default printer;\n","import { SupportOption } from 'prettier';\n\ndeclare module 'prettier' {\n\t// eslint-disable-next-line @typescript-eslint/no-empty-interface\n\tinterface RequiredOptions extends PluginOptions {}\n}\n\nexport interface PluginOptions {\n\tastroSortOrder: SortOrder;\n\tastroAllowShorthand: boolean;\n}\n\nexport const options: Record<keyof PluginOptions, SupportOption> = {\n\tastroSortOrder: {\n\t\tsince: '0.0.1',\n\t\tcategory: 'Astro',\n\t\ttype: 'choice',\n\t\tdefault: 'markup | styles',\n\t\tdescription: 'Sort order for markup, scripts, and styles',\n\t\tchoices: [\n\t\t\t{\n\t\t\t\tvalue: 'markup | styles',\n\t\t\t\tdescription: 'markup | styles',\n\t\t\t},\n\t\t\t{\n\t\t\t\tvalue: 'styles | markup',\n\t\t\t\tdescription: 'styles | markup',\n\t\t\t},\n\t\t],\n\t},\n\tastroAllowShorthand: {\n\t\tsince: '0.0.10',\n\t\tcategory: 'Astro',\n\t\ttype: 'boolean',\n\t\tdefault: false,\n\t\tdescription: 'Enable/disable attribute shorthand if attribute name and expression are the same',\n\t},\n};\n\nexport const parseSortOrder = (sortOrder: SortOrder): SortOrderPart[] =>\n\tsortOrder.split(' | ') as SortOrderPart[];\n\nexport type SortOrder = 'markup | styles' | 'styles | markup';\n\nexport type SortOrderPart = 'markup' | 'styles';\n","import printer from './printer';\nimport { options } from './options';\nimport { Parser, Printer, SupportLanguage } from 'prettier';\nimport { createSyncFn } from 'synckit';\nimport { createRequire } from 'module';\nconst require = createRequire(import.meta.url);\n\n// the worker path must be absolute\nconst parse = createSyncFn(require.resolve('../workers/parse-worker.js'));\n\nexport const languages: Partial<SupportLanguage>[] = [\n\t{\n\t\tname: 'astro',\n\t\tparsers: ['astro'],\n\t\textensions: ['.astro'],\n\t\tvscodeLanguageIds: ['astro'],\n\t},\n];\n\nexport const parsers: Record<string, Parser> = {\n\tastro: {\n\t\tparse: (source) => parse(source),\n\t\tastFormat: 'astro',\n\t\tlocStart: (node) => node.start,\n\t\tlocEnd: (node) => node.end,\n\t},\n};\n\nexport const printers: Record<string, Printer> = {\n\tastro: printer,\n};\n\nconst defaultOptions = {\n\ttabWidth: 2,\n};\n\nexport { options, defaultOptions };\n"],"names":["require","createRequire","createSyncFn","_doc","SassFormatter"],"mappings":"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"}