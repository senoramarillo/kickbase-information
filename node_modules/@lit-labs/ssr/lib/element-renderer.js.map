{"version":3,"file":"element-renderer.js","sourceRoot":"","sources":["../src/lib/element-renderer.ts"],"names":[],"mappings":"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","sourcesContent":["/// <reference lib=\"dom\" />\n\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {escapeHtml} from './util/escape-html.js';\nimport {RenderInfo} from './render-lit-html.js';\n\nexport type Constructor<T> = {new (): T};\n\nexport type ElementRendererConstructor = (new (\n  tagName: string\n) => ElementRenderer) &\n  typeof ElementRenderer;\n\ntype AttributesMap = Map<string, string>;\n\nexport const getElementRenderer = (\n  {elementRenderers}: RenderInfo,\n  tagName: string,\n  ceClass: typeof HTMLElement | undefined = customElements.get(tagName),\n  attributes: AttributesMap = new Map()\n): ElementRenderer => {\n  if (ceClass === undefined) {\n    console.warn(`Custom element ${tagName} was not registered.`);\n    return new FallbackRenderer(tagName);\n  }\n  // TODO(kschaaf): Should we implement a caching scheme, e.g. keyed off of\n  // ceClass's base class to prevent O(n) lookups for every element (probably\n  // not a concern for the small number of element renderers we'd expect)? Doing\n  // so would preclude having cross-cutting renderers to e.g. no-op render all\n  // custom elements with a `client-only` attribute, so punting for now.\n  for (const renderer of elementRenderers) {\n    if (renderer.matchesClass(ceClass, tagName, attributes)) {\n      return new renderer(tagName);\n    }\n  }\n  return new FallbackRenderer(tagName);\n};\n\n/**\n * An object that renders elements of a certain type.\n */\nexport abstract class ElementRenderer {\n  element?: HTMLElement;\n  tagName: string;\n\n  /**\n   * Should be implemented to return true when the given custom element class\n   * and/or tagName should be handled by this renderer.\n   *\n   * @param ceClass - Custom Element class\n   * @param tagName - Tag name of custom element instance\n   * @param attributes - Map of attribute key/value pairs\n   * @returns\n   */\n  static matchesClass(\n    _ceClass: typeof HTMLElement,\n    _tagName: string,\n    _attributes: AttributesMap\n  ) {\n    return false;\n  }\n\n  constructor(tagName: string) {\n    this.tagName = tagName;\n  }\n\n  /**\n   * Should implement server-appropriate implementation of connectedCallback\n   */\n  abstract connectedCallback(): void;\n\n  /**\n   * Should implement server-appropriate implementation of attributeChangedCallback\n   */\n  abstract attributeChangedCallback(\n    name: string,\n    old: string | null,\n    value: string | null\n  ): void;\n\n  /**\n   * Handles setting a property.\n   *\n   * Default implementation sets the property on the renderer's element instance.\n   *\n   * @param name Name of the property\n   * @param value Value of the property\n   */\n  setProperty(name: string, value: unknown) {\n    if (this.element !== undefined) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (this.element as any)[name] = value;\n    }\n  }\n\n  /**\n   * Handles setting an attribute on an element.\n   *\n   * Default implementation calls `setAttribute` on the renderer's element\n   * instance, and calls the abstract `attributeChangedCallback` on the\n   * renderer.\n   *\n   * @param name Name of the attribute\n   * @param value Value of the attribute\n   */\n  setAttribute(name: string, value: string) {\n    if (this.element !== undefined) {\n      const old = this.element.getAttribute(name);\n      this.element.setAttribute(name, value);\n      this.attributeChangedCallback(name, old, value);\n    }\n  }\n\n  /**\n   * Render a single element's ShadowRoot children.\n   */\n  abstract renderShadow(\n    _renderInfo: RenderInfo\n  ): IterableIterator<string> | undefined;\n\n  /**\n   * Render an element's light DOM children.\n   */\n  abstract renderLight(renderInfo: RenderInfo): IterableIterator<string>;\n\n  /**\n   * Render an element's attributes.\n   *\n   * Default implementation serializes all attributes on the element instance.\n   */\n  *renderAttributes(): IterableIterator<string> {\n    if (this.element !== undefined) {\n      const {attributes} = this.element;\n      for (\n        let i = 0, name, value;\n        i < attributes.length && ({name, value} = attributes[i]);\n        i++\n      ) {\n        if (value === '' || value === undefined || value === null) {\n          yield ` ${name}`;\n        } else {\n          yield ` ${name}=\"${escapeHtml(value)}\"`;\n        }\n      }\n    }\n  }\n}\n\n/**\n * An ElementRenderer used as a fallback in the case where a custom element is\n * either unregistered or has no other matching renderer.\n */\nclass FallbackRenderer extends ElementRenderer {\n  private readonly _attributes: {[name: string]: string} = {};\n\n  override setAttribute(name: string, value: string) {\n    this._attributes[name] = value;\n  }\n\n  override *renderAttributes(): IterableIterator<string> {\n    for (const [name, value] of Object.entries(this._attributes)) {\n      if (value === '' || value === undefined || value === null) {\n        yield ` ${name}`;\n      } else {\n        yield ` ${name}=\"${escapeHtml(value)}\"`;\n      }\n    }\n  }\n\n  connectedCallback() {}\n  attributeChangedCallback() {}\n  *renderLight() {}\n  *renderShadow() {}\n}\n"]}