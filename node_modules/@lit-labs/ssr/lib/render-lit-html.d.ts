/// <reference lib="dom" />
import { ElementRenderer, ElementRendererConstructor } from './element-renderer.js';
declare module 'parse5' {
    interface Element {
        isDefinedCustomElement?: boolean;
    }
}
export declare type RenderInfo = {
    /**
     * Element renderers to use
     */
    elementRenderers: ElementRendererConstructor[];
    /**
     * Stack of open custom elements (in light dom or shadow dom)
     */
    customElementInstanceStack: Array<ElementRenderer | undefined>;
    /**
     * Stack of open host custom elements (n-1 will be n's host)
     */
    customElementHostStack: Array<ElementRenderer | undefined>;
    /**
     * An optional callback to notifiy when a custom element has been rendered.
     *
     * This allows servers to know what specific tags were rendered for a given
     * template, even in the case of conditional templates.
     */
    customElementRendered?: (tagName: string) => void;
    /**
     * Flag to defer hydration of top level custom element. Defaults to false.
     */
    deferHydration: boolean;
};
declare global {
    interface Array<T> {
        flat(depth: number): Array<T>;
    }
}
/**
 * Renders a lit-html template (or any renderable lit-html value) to a string
 * iterator. Any custom elements encountered will be rendered if a matching
 * ElementRenderer is found.
 *
 * This method is suitable for streaming the contents of the element.
 *
 * @param value Value to render
 * @param renderInfo Optional render context object that should be passed
 *   to any re-entrant calls to `render`, e.g. from a `renderShadow` callback
 *   on an ElementRenderer.
 */
export declare function render(value: unknown, renderInfo?: Partial<RenderInfo>): IterableIterator<string>;
//# sourceMappingURL=render-lit-html.d.ts.map