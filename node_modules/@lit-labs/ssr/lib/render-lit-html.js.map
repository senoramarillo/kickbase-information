{"version":3,"file":"render-lit-html.js","sourceRoot":"","sources":["../src/lib/render-lit-html.ts"],"names":[],"mappings":"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","sourcesContent":["/// <reference lib=\"dom\" />\n\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport type {TemplateResult, ChildPart} from 'lit';\nimport type {\n  Directive,\n  DirectiveClass,\n  DirectiveResult,\n} from 'lit/directive.js';\n\nimport {nothing, noChange} from 'lit';\nimport {PartType} from 'lit/directive.js';\nimport {isTemplateResult, getDirectiveClass} from 'lit/directive-helpers.js';\nimport {_$LH} from 'lit-html/private-ssr-support.js';\n\nconst {\n  getTemplateHtml,\n  marker,\n  markerMatch,\n  boundAttributeSuffix,\n  overrideDirectiveResolve,\n  setDirectiveClass,\n  getAttributePartCommittedValue,\n  resolveDirective,\n  AttributePart,\n  PropertyPart,\n  BooleanAttributePart,\n  EventPart,\n  connectedDisconnectable,\n} = _$LH;\n\nimport {digestForTemplateResult} from 'lit/experimental-hydrate.js';\n\nimport {\n  ElementRenderer,\n  ElementRendererConstructor,\n  getElementRenderer,\n} from './element-renderer.js';\n\nimport {escapeHtml} from './util/escape-html.js';\n\nimport {\n  traverse,\n  parseFragment,\n  isCommentNode,\n  isElement,\n} from './util/parse5-utils.js';\n\nimport {isRenderLightDirective} from '@lit-labs/ssr-client/directives/render-light.js';\nimport {reflectedAttributeName} from './reflected-attributes.js';\n\nimport {LitElementRenderer} from './lit-element-renderer.js';\n\ndeclare module 'parse5' {\n  interface Element {\n    isDefinedCustomElement?: boolean;\n  }\n}\n\nconst patchedDirectiveCache: WeakMap<DirectiveClass, DirectiveClass> =\n  new Map();\n\n/**\n * Looks for values of type `DirectiveResult` and replaces its Directive class\n * with a subclass that calls `render` rather than `update`\n */\nconst patchIfDirective = (value: unknown) => {\n  // This property needs to remain unminified.\n  const directiveCtor = getDirectiveClass(value);\n  if (directiveCtor !== undefined) {\n    let patchedCtor = patchedDirectiveCache.get(directiveCtor);\n    if (patchedCtor === undefined) {\n      patchedCtor = overrideDirectiveResolve(\n        directiveCtor,\n        (directive: Directive, values: unknown[]) => {\n          // Since the return value may also be a directive result in the case of\n          // nested directives, we may need to patch that as well\n          return patchIfDirective(directive.render(...values));\n        }\n      );\n      patchedDirectiveCache.set(directiveCtor, patchedCtor);\n    }\n    // This property needs to remain unminified.\n    setDirectiveClass(value as DirectiveResult, patchedCtor);\n  }\n  return value;\n};\n\n/**\n * Patches `DirectiveResult` `Directive` classes for AttributePart values, which\n * may be an array\n */\nconst patchAnyDirectives = (\n  part: InstanceType<typeof AttributePart>,\n  value: unknown,\n  valueIndex: number\n) => {\n  if (part.strings !== undefined) {\n    for (let i = 0; i < part.strings.length - 1; i++) {\n      patchIfDirective((value as unknown[])[valueIndex + i]);\n    }\n  } else {\n    patchIfDirective(value);\n  }\n};\n\nconst templateCache = new Map<TemplateStringsArray, Array<Op>>();\n/**\n\n * Operation to output static text\n */\ntype TextOp = {\n  type: 'text';\n  value: string;\n};\n\n/**\n * Operation to output dynamic text from the associated template result value\n */\ntype ChildPartOp = {\n  type: 'child-part';\n  index: number;\n  useCustomElementInstance?: boolean;\n};\n\n/**\n * Operation to output an attribute with bindings. Includes all bindings for an\n * attribute.\n */\ntype AttributePartOp = {\n  type: 'attribute-part';\n  index: number;\n  name: string;\n  ctor: typeof AttributePart;\n  strings: Array<string>;\n  tagName: string;\n  useCustomElementInstance?: boolean;\n};\n\n/**\n * Operation for an element binding. Although we only support directives in\n * element position which cannot emit anything, the opcode needs to index past\n * the part value\n */\ntype ElementPartOp = {\n  type: 'element-part';\n  index: number;\n};\n\n/**\n * Operator to create a custom element instance.\n */\ntype CustomElementOpenOp = {\n  type: 'custom-element-open';\n  tagName: string;\n  ctor: {new (): HTMLElement};\n  staticAttributes: Map<string, string>;\n};\n\n/**\n * Operation to render a custom element's attributes. This is separate from\n * `custom-element-open` because attribute/property parts go in between and need\n * to run and be set on the instance before we render the element's final\n * attributes.\n */\ntype CustomElementAttributesOp = {\n  type: 'custom-element-attributes';\n};\n\n/**\n * Operation to render a custom element's children, usually its shadow root.\n */\ntype CustomElementShadowOp = {\n  type: 'custom-element-shadow';\n};\n\n/**\n * Operation to close a custom element so that its no longer available for\n * bindings.\n */\ntype CustomElementClosedOp = {\n  type: 'custom-element-close';\n};\n\n/**\n * Operation to possibly emit the `<!--lit-node-->` marker; the operation\n * always emits if there were attribtue parts, and may emit if the node\n * was a custom element and it needed `defer-hydration` because it was\n * rendered in the shadow root of another custom element host; we don't\n * know the latter at opcode generation time, and so that test is done at\n * runtime in the opcode.\n */\ntype PossibleNodeMarkerOp = {\n  type: 'possible-node-marker';\n  boundAttributesCount: number;\n  nodeIndex: number;\n};\n\ntype Op =\n  | TextOp\n  | ChildPartOp\n  | AttributePartOp\n  | ElementPartOp\n  | CustomElementOpenOp\n  | CustomElementAttributesOp\n  | CustomElementShadowOp\n  | CustomElementClosedOp\n  | PossibleNodeMarkerOp;\n\n/**\n * For a given TemplateResult, generates and/or returns a cached list of opcodes\n * for the associated Template.  Opcodes are designed to allow emitting\n * contiguous static text from the template as much as possible, with specific\n * non-`text` opcodes interleaved to perform dynamic work, such as emitting\n * values for ChildParts or AttributeParts, and handling custom elements.\n *\n * For the following example template, an opcode list may look like this:\n *\n * ```js\n * html`<div><span>Hello</span><span class=${'bold'}>${template()}</span></div>`\n * ```\n *\n * - `text`\n *   - Emit run of static text: `<div><span>Hello</span><span`\n * - `attribute-part`\n *   - Emit an AttributePart's value, e.g. ` class=\"bold\"`\n * - `text`\n *   - Emit run of static text: `>`\n * - `child-part`\n *   - Emit the ChildPart's value, in this case a TemplateResult, thus we recurse\n *     into that template's opcodes\n * - `text`\n *   - Emit run of static text: `/span></div>`\n *\n * When a custom-element is encountered, the flow looks like this:\n *\n * ```js\n * html`<x-foo staticAttr dynamicAttr=${value}><div>child</div>...</x-foo>`\n * ```\n *\n * - `text`\n *   - Emit open tag `<x-foo`\n * - `custom-element-open`\n *   - Create the CE `instance`+`renderer` and put on\n *     `customElementInstanceStack`\n *   - Call `renderer.setAttribute()` for any `staticAttributes` (e.g.\n *     'staticAttr`)\n * - `attribute-part`(s)\n *   - Call `renderer.setAttribute()` or `renderer.setProperty()` for\n *     `AttributePart`/`PropertyPart`s (e.g. for `dynamicAttr`)\n * - `custom-element-attributes`\n *   - Call `renderer.connectedCallback()`\n *   - Emit `renderer.renderAttributes()`\n * - `text`\n *   - Emit end of of open tag `>`\n * - `possible-node-marker`\n *   - Emit `<!--lit-node n-->` marker if there were attribute parts or\n *      we needed to emit the `defer-hydration` attribute\n * - `custom-element-shadow`\n *   - Emit `renderer.renderShadow()` (emits `<template shadowroot>` +\n *     recurses to emit `render()`)\n * - `text`\n *   - Emit run of static text within tag: `<div>child</div>...`\n * - ...(recurse to render more parts/children)...\n * - `custom-element-close`\n *   - Pop the CE `instance`+`renderer` off the `customElementInstanceStack`\n */\nconst getTemplateOpcodes = (result: TemplateResult) => {\n  const template = templateCache.get(result.strings);\n  if (template !== undefined) {\n    return template;\n  }\n  // The property '_$litType$' needs to remain unminified.\n  const [html, attrNames] = getTemplateHtml(\n    result.strings,\n    result['_$litType$']\n  );\n\n  /**\n   * The html string is parsed into a parse5 AST with source code information\n   * on; this lets us skip over certain ast nodes by string character position\n   * while walking the AST.\n   */\n  const ast = parseFragment(String(html), {\n    sourceCodeLocationInfo: true,\n  });\n\n  const ops: Array<Op> = [];\n\n  /* The last offset of html written to the stream */\n  let lastOffset: number | undefined = 0;\n\n  /* Current attribute part index, for indexing attrNames */\n  let attrIndex = 0;\n\n  /**\n   * Sets `lastOffset` to `offset`, skipping a range of characters. This is\n   * useful for skipping and re-writing lit-html marker nodes, bound attribute\n   * suffix, etc.\n   */\n  const skipTo = (offset: number) => {\n    if (lastOffset === undefined) {\n      throw new Error('lastOffset is undefined');\n    }\n    if (offset < lastOffset) {\n      throw new Error(`offset must be greater than lastOffset.\n        offset: ${offset}\n        lastOffset: ${lastOffset}\n      `);\n    }\n    lastOffset = offset;\n  };\n\n  /**\n   * Records the given string to the output, either by appending to the current\n   * opcode (if already `text`) or by creating a new `text` opcode (if the\n   * previous opocde was not `text)\n   */\n  const flush = (value: string) => {\n    const op = getLast(ops);\n    if (op !== undefined && op.type === 'text') {\n      op.value += value;\n    } else {\n      ops.push({\n        type: 'text',\n        value,\n      });\n    }\n  };\n\n  /**\n   * Creates or appends to a text opcode with a substring of the html from the\n   * `lastOffset` flushed to `offset`.\n   */\n  const flushTo = (offset?: number) => {\n    if (lastOffset === undefined) {\n      throw new Error('lastOffset is undefined');\n    }\n    const previousLastOffset = lastOffset;\n    lastOffset = offset;\n    const value = String(html).substring(previousLastOffset, offset);\n    flush(value);\n  };\n\n  // Depth-first node index, counting only comment and element nodes, to match\n  // client-side lit-html.\n  let nodeIndex = 0;\n\n  traverse(ast, {\n    pre(node, parent) {\n      if (isCommentNode(node)) {\n        if (node.data === markerMatch) {\n          flushTo(node.sourceCodeLocation!.startOffset);\n          skipTo(node.sourceCodeLocation!.endOffset);\n          ops.push({\n            type: 'child-part',\n            index: nodeIndex,\n            useCustomElementInstance:\n              parent && isElement(parent) && parent.isDefinedCustomElement,\n          });\n        }\n        nodeIndex++;\n      } else if (isElement(node)) {\n        // Whether to flush the start tag. This is necessary if we're changing\n        // any of the attributes in the tag, so it's true for custom-elements\n        // which might reflect their own state, or any element with a binding.\n        let writeTag = false;\n        let boundAttributesCount = 0;\n\n        const tagName = node.tagName;\n        let ctor;\n\n        if (tagName.indexOf('-') !== -1) {\n          // Looking up the constructor here means that custom elements must be\n          // registered before rendering the first template that contains them.\n          ctor = customElements.get(tagName);\n          if (ctor !== undefined) {\n            // Write the start tag\n            writeTag = true;\n            // Mark that this is a custom element\n            node.isDefinedCustomElement = true;\n            ops.push({\n              type: 'custom-element-open',\n              tagName,\n              ctor,\n              staticAttributes: new Map(\n                node.attrs\n                  .filter((attr) => !attr.name.endsWith(boundAttributeSuffix))\n                  .map((attr) => [attr.name, attr.value])\n              ),\n            });\n          }\n        }\n        if (node.attrs.length > 0) {\n          for (const attr of node.attrs) {\n            const isAttrBinding = attr.name.endsWith(boundAttributeSuffix);\n            const isElementBinding = attr.name.startsWith(marker);\n            if (isAttrBinding || isElementBinding) {\n              writeTag = true;\n              boundAttributesCount += 1;\n              // Note that although we emit a lit-node comment marker for any\n              // nodes with bindings, we don't account for it in the nodeIndex because\n              // that will not be injected into the client template\n              const strings = attr.value.split(marker);\n              // We store the case-sensitive name from `attrNames` (generated\n              // while parsing the template strings); note that this assumes\n              // parse5 attribute ordering matches string ordering\n              const name = attrNames[attrIndex++];\n              const attrSourceLocation =\n                node.sourceCodeLocation!.attrs![attr.name]!;\n              const attrNameStartOffset = attrSourceLocation.startOffset;\n              const attrEndOffset = attrSourceLocation.endOffset;\n              flushTo(attrNameStartOffset);\n              if (isAttrBinding) {\n                const [, prefix, caseSensitiveName] = /([.?@])?(.*)/.exec(\n                  name as string\n                )!;\n                ops.push({\n                  type: 'attribute-part',\n                  index: nodeIndex,\n                  name: caseSensitiveName,\n                  ctor:\n                    prefix === '.'\n                      ? PropertyPart\n                      : prefix === '?'\n                      ? BooleanAttributePart\n                      : prefix === '@'\n                      ? EventPart\n                      : AttributePart,\n                  strings,\n                  tagName: tagName.toUpperCase(),\n                  useCustomElementInstance: ctor !== undefined,\n                });\n              } else {\n                ops.push({\n                  type: 'element-part',\n                  index: nodeIndex,\n                });\n              }\n              skipTo(attrEndOffset);\n            } else if (node.isDefinedCustomElement) {\n              // For custom elements, all static attributes are stored along\n              // with the `custom-element-open` opcode so that we can set them\n              // into the custom element instance, and then serialize them back\n              // out along with any manually-reflected attributes. As such, we\n              // skip over static attribute text here.\n              const attrSourceLocation =\n                node.sourceCodeLocation!.attrs![attr.name]!;\n              flushTo(attrSourceLocation.startOffset);\n              skipTo(attrSourceLocation.endOffset);\n            }\n          }\n        }\n\n        if (writeTag) {\n          if (node.isDefinedCustomElement) {\n            flushTo(node.sourceCodeLocation!.startTag.endOffset - 1);\n            ops.push({\n              type: 'custom-element-attributes',\n            });\n            flush('>');\n            skipTo(node.sourceCodeLocation!.startTag.endOffset);\n          } else {\n            flushTo(node.sourceCodeLocation!.startTag.endOffset);\n          }\n          ops.push({\n            type: 'possible-node-marker',\n            boundAttributesCount,\n            nodeIndex,\n          });\n        }\n\n        if (ctor !== undefined) {\n          ops.push({\n            type: 'custom-element-shadow',\n          });\n        }\n        nodeIndex++;\n      }\n    },\n    post(node) {\n      if (isElement(node) && node.isDefinedCustomElement) {\n        ops.push({\n          type: 'custom-element-close',\n        });\n      }\n    },\n  });\n  // Flush remaining static text in the template (e.g. closing tags)\n  flushTo();\n  templateCache.set(result.strings, ops);\n  return ops;\n};\n\nexport type RenderInfo = {\n  /**\n   * Element renderers to use\n   */\n  elementRenderers: ElementRendererConstructor[];\n\n  /**\n   * Stack of open custom elements (in light dom or shadow dom)\n   */\n  customElementInstanceStack: Array<ElementRenderer | undefined>;\n\n  /**\n   * Stack of open host custom elements (n-1 will be n's host)\n   */\n  customElementHostStack: Array<ElementRenderer | undefined>;\n\n  /**\n   * An optional callback to notifiy when a custom element has been rendered.\n   *\n   * This allows servers to know what specific tags were rendered for a given\n   * template, even in the case of conditional templates.\n   */\n  customElementRendered?: (tagName: string) => void;\n\n  /**\n   * Flag to defer hydration of top level custom element. Defaults to false.\n   */\n  deferHydration: boolean;\n};\n\nconst defaultRenderInfo = {\n  elementRenderers: [LitElementRenderer],\n  customElementInstanceStack: [],\n  customElementHostStack: [],\n  deferHydration: false,\n};\n\ndeclare global {\n  interface Array<T> {\n    flat(depth: number): Array<T>;\n  }\n}\n\n/**\n * Renders a lit-html template (or any renderable lit-html value) to a string\n * iterator. Any custom elements encountered will be rendered if a matching\n * ElementRenderer is found.\n *\n * This method is suitable for streaming the contents of the element.\n *\n * @param value Value to render\n * @param renderInfo Optional render context object that should be passed\n *   to any re-entrant calls to `render`, e.g. from a `renderShadow` callback\n *   on an ElementRenderer.\n */\nexport function* render(\n  value: unknown,\n  renderInfo?: Partial<RenderInfo>\n): IterableIterator<string> {\n  renderInfo = {...defaultRenderInfo, ...renderInfo};\n  yield* renderValue(value, renderInfo as RenderInfo);\n}\n\nfunction* renderValue(\n  value: unknown,\n  renderInfo: RenderInfo\n): IterableIterator<string> {\n  patchIfDirective(value);\n  if (isRenderLightDirective(value)) {\n    // If a value was produced with renderLight(), we want to call and render\n    // the renderLight() method.\n    const instance = getLast(renderInfo.customElementInstanceStack);\n    if (instance !== undefined) {\n      yield* instance.renderLight(renderInfo);\n    }\n    value = null;\n  } else {\n    value = resolveDirective(\n      connectedDisconnectable({type: PartType.CHILD}) as ChildPart,\n      value\n    );\n  }\n  if (value != null && isTemplateResult(value)) {\n    yield `<!--lit-part ${digestForTemplateResult(value as TemplateResult)}-->`;\n    yield* renderTemplateResult(value as TemplateResult, renderInfo);\n  } else {\n    yield `<!--lit-part-->`;\n    if (\n      value === undefined ||\n      value === null ||\n      value === nothing ||\n      value === noChange\n    ) {\n      // yield nothing\n    } else if (Array.isArray(value)) {\n      for (const item of value) {\n        yield* renderValue(item, renderInfo);\n      }\n    } else {\n      yield escapeHtml(String(value));\n    }\n  }\n  yield `<!--/lit-part-->`;\n}\n\nfunction* renderTemplateResult(\n  result: TemplateResult,\n  renderInfo: RenderInfo\n): IterableIterator<string> {\n  // In order to render a TemplateResult we have to handle and stream out\n  // different parts of the result separately:\n  //   - Literal sections of the template\n  //   - Defined custom element within the literal sections\n  //   - Values in the result\n  //\n  // This means we can't just iterate through the template literals and values,\n  // we must parse and traverse the template's HTML. But we don't want to pay\n  // the cost of serializing the HTML node-by-node when we already have the\n  // template in string form. So we parse with location info turned on and use\n  // that to index into the HTML string generated by TemplateResult.getHTML().\n  // During the tree walk we will handle expression marker nodes and custom\n  // elements. For each we will record the offset of the node, and output the\n  // previous span of HTML.\n\n  const ops = getTemplateOpcodes(result);\n\n  /* The next value in result.values to render */\n  let partIndex = 0;\n\n  for (const op of ops) {\n    switch (op.type) {\n      case 'text':\n        yield op.value;\n        break;\n      case 'child-part': {\n        const value = result.values[partIndex++];\n        yield* renderValue(value, renderInfo);\n        break;\n      }\n      case 'attribute-part': {\n        const statics = op.strings;\n        const part = new op.ctor(\n          // Passing only object with tagName for the element is fine since the\n          // directive only gets PartInfo without the node available in the\n          // constructor\n          {tagName: op.tagName} as HTMLElement,\n          op.name,\n          statics,\n          connectedDisconnectable(),\n          {}\n        );\n        const value =\n          part.strings === undefined ? result.values[partIndex] : result.values;\n        patchAnyDirectives(part, value, partIndex);\n        let committedValue: unknown = noChange;\n        // Values for EventParts are never emitted\n        if (!(part.type === PartType.EVENT)) {\n          committedValue = getAttributePartCommittedValue(\n            part,\n            value,\n            partIndex\n          );\n        }\n        // We don't emit anything on the server when value is `noChange` or\n        // `nothing`\n        if (committedValue !== noChange) {\n          const instance = op.useCustomElementInstance\n            ? getLast(renderInfo.customElementInstanceStack)\n            : undefined;\n          if (part.type === PartType.PROPERTY) {\n            yield* renderPropertyPart(instance, op, committedValue);\n          } else if (part.type === PartType.BOOLEAN_ATTRIBUTE) {\n            // Boolean attribute binding\n            yield* renderBooleanAttributePart(instance, op, committedValue);\n          } else {\n            yield* renderAttributePart(instance, op, committedValue);\n          }\n        }\n        partIndex += statics.length - 1;\n        break;\n      }\n      case 'element-part': {\n        // We don't emit anything for element parts (since we only support\n        // directives for now; since they can't render, we don't even bother\n        // running them), but we still need to advance the part index\n        partIndex++;\n        break;\n      }\n      case 'custom-element-open': {\n        // Instantiate the element and its renderer\n        const instance = getElementRenderer(\n          renderInfo,\n          op.tagName,\n          op.ctor,\n          op.staticAttributes\n        );\n        // Set static attributes to the element renderer\n        for (const [name, value] of op.staticAttributes) {\n          instance.setAttribute(name, value);\n        }\n        renderInfo.customElementInstanceStack.push(instance);\n        renderInfo.customElementRendered?.(op.tagName);\n        break;\n      }\n      case 'custom-element-attributes': {\n        const instance = getLast(renderInfo.customElementInstanceStack);\n        if (instance === undefined) {\n          throw new Error(\n            `Internal error: ${op.type} outside of custom element context`\n          );\n        }\n        // Perform any connect-time work via the renderer (e.g. reflecting any\n        // properties to attributes, for example)\n        if (instance.connectedCallback) {\n          instance.connectedCallback();\n        }\n        // Render out any attributes on the instance (both static and those\n        // that may have been dynamically set by the renderer)\n        yield* instance.renderAttributes();\n        // If deferHydration flag is true or if this element is nested in\n        // another, add the `defer-hydration` attribute, so that it does not\n        // enable before the host element hydrates\n        if (\n          renderInfo.deferHydration ||\n          renderInfo.customElementHostStack.length > 0\n        ) {\n          yield ' defer-hydration';\n        }\n        break;\n      }\n      case 'possible-node-marker': {\n        // Add a node marker if this element had attribute bindings or if it\n        // was nested in another and we rendered the `defer-hydration` attribute\n        // since the hydration node walk will need to stop at this element\n        // to hydrate it\n        if (\n          op.boundAttributesCount > 0 ||\n          renderInfo.customElementHostStack.length > 0\n        ) {\n          yield `<!--lit-node ${op.nodeIndex}-->`;\n        }\n        break;\n      }\n      case 'custom-element-shadow': {\n        const instance = getLast(renderInfo.customElementInstanceStack);\n        if (instance === undefined) {\n          throw new Error(\n            `Internal error: ${op.type} outside of custom element context`\n          );\n        }\n        if (instance.renderShadow !== undefined) {\n          renderInfo.customElementHostStack.push(instance);\n          const shadowContents = instance.renderShadow(renderInfo);\n          // Only emit a DSR if renderShadow() emitted something (returning\n          // undefined allows effectively no-op rendering the element)\n          if (shadowContents !== undefined) {\n            yield '<template shadowroot=\"open\">';\n            yield* shadowContents;\n            yield '</template>';\n          }\n          renderInfo.customElementHostStack.pop();\n        }\n        break;\n      }\n      case 'custom-element-close':\n        renderInfo.customElementInstanceStack.pop();\n        break;\n      default:\n        throw new Error('internal error');\n    }\n  }\n\n  if (partIndex !== result.values.length) {\n    throw new Error(\n      `unexpected final partIndex: ${partIndex} !== ${result.values.length}`\n    );\n  }\n}\n\nfunction* renderPropertyPart(\n  instance: ElementRenderer | undefined,\n  op: AttributePartOp,\n  value: unknown\n) {\n  value = value === nothing ? undefined : value;\n  // Property should be reflected to attribute\n  const reflectedName = reflectedAttributeName(op.tagName, op.name);\n  if (instance !== undefined) {\n    instance.setProperty(op.name, value);\n  }\n  if (reflectedName !== undefined) {\n    yield `${reflectedName}=\"${escapeHtml(String(value))}\"`;\n  }\n}\n\nfunction* renderBooleanAttributePart(\n  instance: ElementRenderer | undefined,\n  op: AttributePartOp,\n  value: unknown\n) {\n  if (value && value !== nothing) {\n    if (instance !== undefined) {\n      instance.setAttribute(op.name, '');\n    } else {\n      yield op.name;\n    }\n  }\n}\n\nfunction* renderAttributePart(\n  instance: ElementRenderer | undefined,\n  op: AttributePartOp,\n  value: unknown\n) {\n  if (value !== nothing) {\n    if (instance !== undefined) {\n      instance.setAttribute(op.name, String(value ?? ''));\n    } else {\n      yield `${op.name}=\"${escapeHtml(String(value ?? ''))}\"`;\n    }\n  }\n}\n\nconst getLast = <T>(a: Array<T>) => a[a.length - 1];\n"]}